分发糖果   贪心算法  1.预先初始两个数组，全部填充为1  2.左迭代，当前比之前高，当前的糖果等于之前的数量加1  3.右迭代  4.最终最小糖果数等于最大左右数组
分糖果I   min(cnt,n/2)
分糖果II   数组迭代控制糖果数量和分配位置和数量  最后加上负数糖果
386. 字典序排数 dfs [1,10,11,12,13,2,3,4,5,6,7,8,9]  把字典序看成多层10叉树的组合
440. 字典序的第K小数字   1.判断cur与cur+1 之间的step 2.如果step大于k，答案肯定在其中，cur*10 k-- 3.否则移动cur++ k-steps
1163. 按字典序排在最后的子串  从中间字母最大的位置到结尾组成的子串为最后最大的子串  1.找字母最大的位置  2.截取字符串
1061. 按字典序排列最小的等效字符串  并查集 根据AB组成并查集，S根据并查集查询所属组
93. 复原IP地址  回溯 字符串substring
10. 正则表达式匹配 - difficult 动态规划dp  1.当前字符能匹配或者能与任意字符匹配 2.当前字符为*：2.1 0匹配 2.2多个匹配
103. 二叉树的锯齿形 层次遍历 使用层次遍历，使用LinkedList控制插入的顺序 addFirst addLast
22. 括号生成    dfs   1.左括号不能超过n  2.右括号不能超过左括号的个数
32. 最长有效括号  <栈，双指针>  1.(push,否则pop i-peek 2.{ left++ } right++ 左右迭代一次 求max
45. 跳跃游戏 II  贪心算法  每次在跳跃范围内找跳跃最远的数
71. 简化路径   栈  1.split . .. "" "str" push pop stringbuilder.append
114. 二叉树展开为链表   深度优先搜索   1.将左子树插入到右子树的地方  2.将原来的右子树接到左子树的最右边节点  3.考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null
51. N皇后   回溯问题    1.备忘录 col master slave剪枝  2.convert2board replace Q 3.满足条件
108. 将有序数组转换为二叉搜索树  dfs 递归   找到中间节点，一分为二，进入递归
234.回文链表    双指针   1.快慢指针找到链表中点  2.翻转后续链表  3.对比两个链表 4.恢复链表
155. 最小栈  数据栈和辅助栈   辅助栈用于记录比栈顶小的元素
44. 通配符匹配  ？*     双指针 1.两字符相等或者p字符为? 指针相加  2.p指针为* 标记两指针当前位置  3.不匹配 直接移动i j位置 4.p末尾不为* 不匹配
415. 字符串相加   字符串相加  个位数相加 carry进位  翻转字符串
74.搜索二维矩阵  双指针数组搜索 从左下角开始搜索，大于target时，向上移动，小于target时，向右移动
203.移除链表元素  双指针   加上哨兵节点 dummy
35. 搜索插入位置  二分法   标准二分法搜索
38. 外观数列  字符串   字符串迭代，比较当前字符与之前字符是否相同，拼接频次和字母
297. 二叉树的序列化与反序列化  序列化-层次遍历 反序列化-dfs
393. UTF-8 编码验证  位操作   1.判断首位1的长度  2.判断接下来每位为10的个数
# 作为调用方和被调用放如何对避免服务雪崩？

# rpc接口的超时时间时如何设置得？

# 服务容灾是如何做的？

# 你们工作中采用的微服务是如何部署的？

# 分布式事务








# 缓存击穿以及雪崩防止; 布隆过滤器方式(2-3)
    - 缓存穿透，是指查询一个数据库一定不存在的数据。每次查询都是空，每次又不进行缓存，容易压垮数据库。redis采用缓存空值的方法
        - 使用布隆过滤器对请求的key进行一层过滤，过滤掉系统认为不存在不合法的key
        - 使用双重验证锁解决高并发环境下的缓存穿透问题：1.从缓存中读取，校验object是否为null，如果不为空，返回缓存的值，否则  2.synchronized(this) ，再次从缓存中读取 3.如果为空的话，访问数据库，否则查询缓存
    - 缓存雪崩：在某一段时间内，缓存集中过期失效。不同分类的商品缓存不同的周期，热点商品缓存长，冷门商品缓存短
       - 对缓存的失效时间加上一个随机值，使失效时间分散一点，尽量避免集中失效
       - hystrix限流&降级组件，避免MySQL被打死
       - 如果真的发生雪崩，我们还可以用redis的RDB或AOF重启redis快速从磁盘加载缓存数据
    
    - 布隆过滤器：布隆过滤器是一个 bit 数组，特点是高效的插入和查询，缺点是返回的结果是概率性的
        - 使用多个hash函数生成多个hash值，对每一个hash值指向的bit位置为1。查询时，如果指定的位置不为1，肯定不存在；如果全部为1，可能存在
        - Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。
          但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。
          拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，
          而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上

# 实现大文件的上传和断点续传
    - 1.计算全文件的md5，发送给服务器，服务器已存在，返回秒传成功，
    - 2.服务端不存在时，返回已经存在的切片序列，前端过滤已经上传的切片，批量上传没有的切片和每个切片的md5
    - 3.最后前端确定所有切片发完，发一个合并请求，做异步服务端合并，并校验合并完的md5，上传结束


# 分布式锁, 节点类型 (2-2)
    - 分布式锁/分布式队列 ： 根据zookeeper的一致性文件系统，在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该临时节点。
     - PERSISTENT-持久节点：除非手动删除，否则节点一直存在于Zookeeper上
     - EPHEMERAL-临时节点：临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。
     - PERSISTENT_SEQUENTIAL-持久顺序节点，基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。
     - EPHEMERAL_SEQUENTIAL-临时顺序节点，基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字
# RPC&SOA
    - SOA:面向服务的架构，WebService/Dubbo作为服务
    - RPC:远程过程调用协议，通过网络调用远端服务，不知道具体实现，Thrift
# 服务治理,限流监控,降级,熔断等(2-3)
    - 服务治理：主要是解决微服务架构下微服务数量众多导致维护成本巨大的缺点，让维护人员从人工维护中解放，由服务自行维护
      微服务作为服务的提供方，主动向服务中心注册，服务的消费主要通过从服务中心查询需要的服务并进行调用
    - 服务发现监控Eureka：用于监控服务的注册与调用
     - Fiegn：简化rest接口调用操作，依赖于Ribbon
    - 服务降级：当服务器压力剧增的时候，对服务页面有策略的不处理或者简单处理，保证基本服务正常
        - 1.超时降级  2.失败次数降级  3.故障降级  4.限流降级  
    - 断路器（熔断）hystrix：1.断路器机制  2.Fallback  3.资源隔离
       1.断路器机制：当Hystrix Command 一定时间内请求后端服务失败数量超过一个阈值比例，该服务的断路器就会打开，返回一个由开发者设定的fallback
       2.fallback：由Hystrix保护的服务调用，也可以是固定的值，排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）
       3.资源隔离：不同的微服务调用使用不同的线程池来管理
    - 负载均衡Ribbon：1.最小请求数 2.轮询算法(默认)  3.随机算法
    - 服务网关zuul：提供一个统一的网关接口，实现服务的转发
    - 分布式配置：为微服务架构中的微服务提供集中化的外部配置支持
# 什么是幂等性
    - 同一个操作无论请求多少次，结果都相同

# 一致性hash (2-2)
    - 原因：hash(object)%N +1-1的后所有的缓存都失效了
    - 一致性hash算法，在移除和添加结点的时候，尽可能小的改变已存在的key映射关系
    - 1.hash算法将value映射到一个0-32位的key值环形空间
    - 2.将对象和cache都映射到环形空间上
    - 3.把对象映射到缓存结点上，从对象的key值触发沿着顺时针方向，遇到的第一个cache，就将该对象存储在这个cache结点上
    - 4.如果移除一个cache结点，受影响的object将继续顺时针方向寻找下一个cache结点
    - 5.虚拟节点是为了使得缓存空间都得到合理的利用，解决服务结点的数据倾斜问题，hash环中虚拟节点均匀分布，多个虚拟结点对应一个实际结点

# 缓存击穿以及雪崩防止; 布隆过滤器方式(2-3)
    - 缓存穿透，是指查询一个数据库一定不存在的数据。每次查询都是空，每次又不进行缓存，容易压垮数据库。redis采用缓存空值的方法
        - 使用布隆过滤器对请求的key进行一层过滤，过滤掉系统认为不存在不合法的key
        - 使用双重验证锁解决高并发环境下的缓存穿透问题：1.从缓存中读取，校验object是否为null，如果不为空，返回缓存的值，否则  2.synchronized(this) ，再次从缓存中读取 3.如果为空的话，访问数据库，否则查询缓存
    - 缓存雪崩：在某一段时间内，缓存集中过期失效。不同分类的商品缓存不同的周期，热点商品缓存长，冷门商品缓存短
       1.并发量不是很多的时候，使用加锁排队  
               2.为key设置不同的缓存时间，比如可以在原有的失效时间基础上增加一个随机值，
               比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效
               的事件
    
    - 布隆过滤器：布隆过滤器是一个 bit 数组，特点是高效的插入和查询，缺点是返回的结果是概率性的
        - 使用多个hash函数生成多个hash值，对每一个hash值指向的bit位置为1。查询时，如果指定的位置不为1，肯定不存在；如果全部为1，可能存在
        - Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。
          但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。
          拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，
          而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上

# 实现大文件的上传和断点续传
    - 1.计算全文件的md5，发送给服务器，服务器已存在，返回秒传成功，
    - 2.服务端不存在时，返回已经存在的切片序列，前端过滤已经上传的切片，批量上传没有的切片和每个切片的md5
    - 3.最后前端确定所有切片发完，发一个合并请求，做异步服务端合并，并校验合并完的md5，上传结束


# 分布式锁, 节点类型 (2-2)
    - 分布式锁/分布式队列 ： 根据zookeeper的一致性文件系统，在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该临时节点。
     - PERSISTENT-持久节点：除非手动删除，否则节点一直存在于Zookeeper上
     - EPHEMERAL-临时节点：临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。
     - PERSISTENT_SEQUENTIAL-持久顺序节点，基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。
     - EPHEMERAL_SEQUENTIAL-临时顺序节点，基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字
# RPC&SOA
    - SOA:面向服务的架构，WebService/Dubbo作为服务
    - RPC:远程过程调用协议，通过网络调用远端服务，不知道具体实现，Thrift
# 服务治理,限流监控,降级,熔断等(2-3)
    - 服务治理：主要是解决微服务架构下微服务数量众多导致维护成本巨大的缺点，让维护人员从人工维护中解放，由服务自行维护
      微服务作为服务的提供方，主动向服务中心注册，服务的消费主要通过从服务中心查询需要的服务并进行调用
    - 服务发现监控Eureka：用于监控服务的注册与调用
     - Fiegn：简化rest接口调用操作，依赖于Ribbon
    - 服务降级：当服务器压力剧增的时候，对服务页面有策略的不处理或者简单处理，保证基本服务正常
        - 1.超时降级  2.失败次数降级  3.故障降级  4.限流降级  
    - 断路器（熔断）hystrix：1.断路器机制  2.Fallback  3.资源隔离
       1.断路器机制：当Hystrix Command 一定时间内请求后端服务失败数量超过一个阈值比例，该服务的断路器就会打开，返回一个由开发者设定的fallback
       2.fallback：由Hystrix保护的服务调用，也可以是固定的值，排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）
       3.资源隔离：不同的微服务调用使用不同的线程池来管理
    - 负载均衡Ribbon：1.最小请求数 2.轮询算法(默认)  3.随机算法
    - 服务网关zuul：提供一个统一的网关接口，实现服务的转发
    - 分布式配置：为微服务架构中的微服务提供集中化的外部配置支持
# 什么是幂等性
    - 同一个操作无论请求多少次，结果都相同

# 一致性hash (2-2)
    - 原因：hash(object)%N +1-1的后所有的缓存都失效了
    - 一致性hash算法，在移除和添加结点的时候，尽可能小的改变已存在的key映射关系
    - 1.hash算法将value映射到一个0-32位的key值环形空间
    - 2.将对象和cache都映射到环形空间上
    - 3.把对象映射到缓存结点上，从对象的key值触发沿着顺时针方向，遇到的第一个cache，就将该对象存储在这个cache结点上
    - 4.如果移除一个cache结点，受影响的object将继续顺时针方向寻找下一个cache结点
    - 5.虚拟节点是为了使得缓存空间都得到合理的利用，解决服务结点的数据倾斜问题，hash环中虚拟节点均匀分布，多个虚拟结点对应一个实际结点


# 高并发系统的设计与实现
    在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。
    
    缓存：缓存的目的是提升系统访问速度和增大系统处理容量
    降级：降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行
    限流：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理
    
# 常见的限流算法：
     常见的限流算法有计数器、漏桶和令牌桶算法。
       
      计数器：滑动窗口，求窗口中的最大值
      漏桶
          - 漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉
      令牌桶算法：
          - 生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌
          - 由信号量维护令牌，限制的是并发访问临界资源的线程数，
             每次调用acquire获取令牌，如果没有可用的话，会一直阻塞到获取令牌为止，调用release()方法则会释放自己持有的permit，即用完了再还回去
          - 分布式条件下把把permit放到Redis中
          
          
     local key = KEYS[1] --限流KEY（一秒一个）
     local limit = tonumber(ARGV[1]) --限流大小
     local current = tonumber(redis.call('get', key) or "0")
     if current + 1 > limit then --如果超出限流大小
         return 0
     else --请求数+1，并设置2秒过期
         redis.call("INCRBY", key,"1")
         redis.call("expire", key,"2")
     end
     return 1
     
     使用Redis实现，存储两个key，一个用于计时，一个用于计数。请求每调用一次，计数器增加1，若在计时器时间内计数器未超过阈值，则可以处理任务
     使用redis进行限流，其很好地解决了分布式环境下多实例所导致的并发问题。因为使用redis设置的计时器和计数器均是全局唯一的
     https://segmentfault.com/a/1190000016552464
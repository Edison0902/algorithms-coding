# 分布式事务(2-3)
    - 事务的属性：
        - 原子性：执行单元中的操作要么全部成功要么全部失败
        - 一致性：操作执行的前后都是完整的
        - 隔离性：事务与事务之间是完全隔离的，只有事务提交后其他事务才可以查询到最新的数据
        - 持久性：事务完成后对数据的改变会完整的存储起来
    - 分布式事务指多个系统通过网络共同完成一个事务，需要保证事务的ACID
        - 例如在下单场景中，库存和订单如果不在一个节点上，就涉及分布式事务
        - 两阶段提交协议（2PC）：由协调者和多个参与者组成，
            - 第一阶段权限校验和资源准备阶段
            - 第二阶段提交阶段
            - 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息，否则发送提交(Commit)消息，释放资源
            - 独占资源效率低下
        - 事务补偿（TCC）：try满足条件检测 confirm执行资源操作  cancel有一方出现失败全部回滚。保证数据最终一致性，灵活性好，开发复杂
            - 保持最终一致性。最终一致性并不需要长时间持有资源的锁，每一个事务其实都是相互独立的，所以tcc的效率会更高
        - 基于消息队列的分布式事务：1.支付成功，本地事务更新订单状态，并向消息表写入减库存 
            2.定时任务扫描消息表，取出减库存消息并发向MQ  
            3.库存端收到消息先检测本地消息表是否有相同消息，存在说明已减库存，否则操作本地数据库减库存，并向本地消息表添加减库存消息，通过本地事务保证，
            4.向MQ发送完成减库存的消息
            5.收到消息后，删除本地消息表的减库存消息，提交事务
            - 本地消息的作用：即使宕机后恢复，确保消息能够被mq接收。做消息的持久化
        - 使用MQ事务消息：Rocketmq支持事务，如果确认消息失败会让发送端回滚。实现最终一致性，不需要依赖本地事务
        - 
    # cap、 base原则理解
      - cap：分布式系统在设计时只能在一致性(Consistency)、可用性(Availability)、分区容忍性(Partition Tolerance)中满足两种，无法兼顾三种
          - 一致性(Consistency)：多个节点的数据需要保证同一时刻数据的一致性
          - 可用性(Availability)：一个节点宕机不影响整个系统对外提供服务
          - 分区容忍性(Partition Tolerance)：解决由于网络分区导致的数据不完整和无法访问的问题
      - 无法同时兼顾CAP：保持分区容忍性不变的情况下，如果要提高可用性，就要增加多个结点，如果要保持一致性就要实现每个结点的数据一致，结点越多可用性越高，数据一致性越低
          - CA：关系型数据库
          - AP：NoSQL数据库
          - CP：跨行转账
          - 在分布式系统中，AP用得比较多，牺牲实时一致性，保持最终一致性，比如取消订单，退款稍后到帐，事务走完即可
      - base：BA指的是基本业务可用性，支持分区失败，S表示柔性状态，也就是允许短时间内不同步，E表示最终一致性，数据最终是一致的，但是实时是不一致的。
              原子性和持久性必须从根本上保障，为了可用性、性能和服务降级的需要，只有降低一致性和隔离性的要求。



# 内连接
    - MySQL 中内连接是在交叉连接的结果集上返回满足条件的记录
# 外连接
    - 外连接将表氛围基表和参考表，更加注重两张表之间的关系，按照连接顺序可以分为左外连接和右外连接
        - 左外连接：匹配左表中的每一行及右表中符合条件的行
# 如何创建联合索引
    - 1.create table ... KEY `sindex` (`aaa`, `bbb`, `ccc`)
    - 2.alter table add index `sindex` (`aaa`, `bbb`, `ccc`)
# 联合索引的存储结构
    - 联合索引(col1, col2,col3)也是一棵B+Tree，
        其非叶子节点存储的是第一个关键字的索引，
        而叶节点存储的则是三个关键字col1、col2、col3三个关键字的数据，
        且按照col1、col2、col3的顺序进行排序。
     - select的时候，第一列存在，索引能生效，3列都存在，索引全部生效，否则只能部分生效
    - 最左前缀原则：
      - 联合索引的B+Tree是按照第一个关键字进行索引排列的，查找的时候直接二分法查找第一列的索引，然后再第二列，再第三列

# where，having
       - where：从数据表中的字段直接进行筛选
       - having：从前面select后筛选的字段再进行筛选

# 聚簇索引与非聚簇索引(2-1)
    聚集索引
        - 数据表中数据的物理索引与键值的逻辑索引相同，inonodb中聚集索引就是主键索引，如果主键没有定义，该表的第一个唯一非空索引作为聚集索引，否则生成隐藏的6字节自增主键作为聚集索引
        - 一个表只能由一个聚集索引，可以有多个非聚集索引
        - 聚集索引整体是一个B+树，非叶子节点存放的是键值，叶子节点存放的是行数据，叶子之间通过双向链表连接
        - 非聚集索引，叶子节点存的是字段的键值，通过非聚集索引的键值找到对应的聚集索引的键值，再通过聚集索引的键值找到某行的数据
    聚集索引优点：
        1、以最快的速度缩小查询范围。
        2、以最快的速度进行字段排序。
    聚集索引使用场合：
        1、此列包含有限数目的不同值。
        2、查询的结果返回一个区间的值。
        3、查询的结果返回某值相同的大量结果集。



# 表格存储引擎innoDB Mysiam(2-1)
    - 事务：Myisam不支持事务，Myisam强调的是性能，执行速度比innodb快；innodb支持事务，默认开启自动提交
    - 主键：Myisam允许没有任何索引和主键的表存在，索引保存行的地址；innodb如果没有主键或者非空唯一索引，就会自动生成隐藏自增6字节主键作为聚集索引
    - 外键：Myisam不支持外键；innodb支持外键
    - 表锁：Myisam只执行表级别锁，select，update，delete，insert语句都会给表自动加锁；innodb支持行级锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。大幅度提高了多用户并发操作性能
    - CRUD：Myisam执行大量SELECT效率高；innodb执行大量insert，update，delete效率高，全删使用truncate
    1) MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。
    2) InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。大尺寸数据倾向于innodb，因为事务日志和故障恢复
     
# 主从同步(2-2)
    - 主服务器操作数据库记录二进制日志，从服务器根据二进制日志自动执行更新
    - 二进制日志
        - 1.sql语句  2.每一行数据变化的信息  3.混合复制：默认用sql，出问题时用行数据复制
    - 主服务器只要发生变化，立马记录到binary log中
    - 从服务器启动一个thread连接到数据库中，请求Master变化的二进制日志
    - 从服务器获取到二进制日志，保存到自己的relay log中
    - 从服务器有一个SQL thread定期检查relay log是否变化，变化就自动更新
    
    为什么要用主从复制
       - 实现数据的异地备份
       - 实现负载均衡,读写分离
       - 提高数据库系统的可用性
   
# 读写分离(2-2)
    - 通过Mysql的主从复制结构，可以将读操作分散到从服务器中，并且对从服务器实现负载均衡
    - 问题：主从延迟
        - 从服务器通过主服务器的binary log文件进行同步有1秒的延迟，如果付款后，主库写入数据，但是从库查询不到数据
            - 1.数据库层面：分库，主库拆成读个主库，减小写并发量 2.从库开启多个线程并行复制
            - 2.软件层面：1.使用缓存保存状态，延缓查询时机  2.分配机制：选择不同数据源，关键业务由主库承担，
            
# 事务隔离级别(2-2)
    - Read uncommitted读未提交： 一个事务可以读取另一个未提交事务的数据 [脏读]
    - Read committed读已提交：一个事务要等另一个事务提交后才能读取数据，不能防止update，一个事务范围内两个相同的查询却返回了不同数据 [不可重复读]
    - Repeatable read可重复读【默认】：事务开启，不允许其他事务的UPDATE修改操作，两次读取的结果一致 由insert导致[幻读]：一次事务里，多次查询后，结果集的个数不一致
    - Serializable串行化：事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用
# 幻读解决(2-2)
    - 幻读：一次事务里，多次查询后，结果集的个数不一致
    - 为什么要解决幻读：高并发场景中，要保证事务之间的隔离性和数据的一致性
    - mysql innodb引擎通过MVCC快照读和next-key(当前读)两种模式解决了幻读问题
    - 在快照读读情况下，mysql通过mvcc来避免幻读，简单的select操作
        - MVCC：多版本并发控制。InnoDB为每行记录添加了一个版本号（系统版本号），每当修改数据时，版本号加一；
        在读取事务开始时，系统会给事务一个当前版本号，事务会读取版本号<=当前版本号的数据，这时就算另一个事务插入一个数据，并立马提交，
        新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。
    - 在当前读读情况下，mysql通过next-key来避免幻读，next-key锁定一个范围的数据再事务提交之前不能变动
    
# B+树(2-3)
    - B树是m阶多路平衡查找树
      - 1.树中的每一个节点最多有m个子树
      - 2.除根节点和叶子节点外，其他节点最少有m/2个子节点
      - 3.所有的叶子节点都在同一层
      - 4.节点中的关键字顺序按照升序排列
    - B+树是B树的一种变体
        - 1.B+树非叶子节点不存在数据，只存储索引，每个非叶子节点存储的索引更多，树的层级更小
        - 2.叶子节点包含全部的关键信息，且叶子节点之间通过双向链表进行连接，查询更快
    # ZK
    - ZooKeeper是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作
    - 服务的注册与发现
    - 心跳检测，集群管理


# 数据库的优化
    - 1.选取最合适的字段属性，数据库的表越小，执行的查询也就越快，因此为了获得更好的性能，将表中字段的宽度设置得尽量的小
    - 2.使用连接（JOIN）来代替子查询(Sub-Queries)：MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作
    - 3.使用联合(UNION)来代替手动创建的临时表。它可以把多个select的查询合并到一个查询中，查询会话结束时，临时表会自动删除，保证数据完整高效
    - 4.事务：使用事务来保证多用户访问同一个数据源时，利用锁定数据库提供一种安全的访问方式。BEGIN;COMMIT;
    - 5.锁定表：事务具有独占性，会影响数据库的性能，可以通过锁定表的方式获取更好的性能
    - 6.使用索引：可以让数据库服务器检索特定行的速度提升，ALTER TABLE或CREATE INDEX创建索引
    - 7.优化查询语句：避免使用!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符.会使得系统无法使用索引，用exists代替in
        - 能够用BETWEEN的就不要用IN
        
    MySQL表字段类型
        - INT，11位宽度
        - TINYINT ，0-255
        - SMALLINT ，65535
        - MEDIUMINT 
        - BIGINT ，20位
        - FLOAT，默认为10,2
        - DOUBLE，默认为16,4
        - DECIMAL
        
        - DATE 日期 YYYY-MM-DD
        - DATETIME 日期和时间 YYYY-MM-DD HH:MM:SS
        - TIMESTAMP 时间戳 YYYYMMDDHHMMSS
        
        - CHAR，固定长度的字符串1-255
        - VARCHAR，可变长度的字符串 
        - ENUM ，枚举
        - BLOB ，二进制大对象，存储图像，65535
# mysql索引理解
        - B树是m阶多路平衡查找树
              - 1.树中的每一个节点最多有m个子树
              - 2.除根节点和叶子节点外，其他节点最少有m/2个子节点
              - 3.所有的叶子节点都在同一层
              - 4.节点中的关键字顺序按照升序排列
            - B+树是B树的一种变体
                - 1.B+树非叶子节点不存在数据，只存储索引，每个非叶子节点存储的索引更多，树的层级更小
                - 2.叶子节点包含全部的关键信息，且叶子节点之间通过双向链表进行连接，查询更快
# Mysql常用存储引擎以及应用场景
            
            - 事务：Myisam不支持事务，Myisam强调的是性能，执行速度比innodb快；innodb支持事务，默认开启自动提交
                - 主键：Myisam允许没有任何索引和主键的表存在，索引保存行的地址；innodb如果没有主键或者非空唯一索引，就会自动生成隐藏自增6字节主键作为聚集索引
                - 外键：Myisam不支持外键；innodb支持外键
                - 表锁：Myisam只执行表级别锁，select，update，delete，insert语句都会给表自动加锁；innodb支持行级锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。大幅度提高了多用户并发操作性能
                - CRUD：Myisam执行大量SELECT效率高；innodb执行大量insert，update，delete效率高，全删使用truncate
                1) MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。
                2) InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。大尺寸数据倾向于innodb，因为事务日志和故障恢复

# 聚簇索引和非聚簇索引的区别
        聚集索引
            - 数据表中数据的物理索引与键值的逻辑索引相同，inonodb中聚集索引就是主键索引，如果主键没有定义，该表的第一个唯一非空索引作为聚集索引，否则生成隐藏的6字节自增主键作为聚集索引
            - 一个表只能由一个聚集索引，可以有多个非聚集索引
            - 聚集索引整体是一个B+树，非叶子节点存放的是键值，叶子节点存放的是行数据，叶子之间通过双向链表连接
            - 非聚集索引，叶子节点存的是字段的键值，通过非聚集索引的键值找到对应的聚集索引的键值，再通过聚集索引的键值找到某行的数据
        聚集索引优点：
            1、以最快的速度缩小查询范围。
            2、以最快的速度进行字段排序。
        聚集索引使用场合：
            1、此列包含有限数目的不同值。
            2、查询的结果返回一个区间的值。
            3、查询的结果返回某值相同的大量结果集。
# Mysql索引数据结构及优化
       Mysql的两种主要的存储引擎都依赖的数据结构为B+tree
       目前比较主流的存储引擎貌似是MyISAM和InnoDB两种
           - MyISAM使用B+tree存储引擎结构，叶节点的data域存放的是数据记录的地址
           - MyISAM采用的是索引文件和数据文件分离存储，索引文件中存储的是数据文件中相应数据的地址，只对索引采取B+tree数据结构
           - 主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复
         
           - InnoDB的数据文件本身就是索引文件，数据文件就按照B+tree的结构存储，这棵树的key即是InnoDB中的主键，
               这棵树的叶结点对应的data域存储的是完整的数据记录，这种索引叫做聚集索引，MyISAM则不是非要主键，MyISAM的索引叫做非聚集索引
           - 在InnoDB中的辅助索引和MyISAM中的辅助索引也不一样，InnoDB的辅助索引也采用的B+tree结构存储，
              但是辅助索引树的叶结点的data域则存储的是相应的主键值，而不是像MyISAM存储地址
           - 辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录，所以InnoDB的主键最好使用单调有序的字段
           
       优化：
           - where后面的索引列不能包含表达式和函数
           - 将选择性最好的列放在索引的最前l列
           - 减少创建冗余索引，当前条查询语句相关的索引数量越多，效率越低
# 索引匹配规则
    - explain：查看sql语句的执行计划   index 全表查询  ref 找符合条件的索引
    - 索引的最左匹配特性：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，b+树会优先比较name来确定下一步的所搜方向
    - 复合索引：复合索引中，mysql优化器会纠正sql以什么样的顺序执行效率会更高，mysql查询优化器最终会以这种顺序进行查询执行

# 写一个sql,查询语文成绩前十的学生名字和成绩

# sql语句慢查询优化(explain去看有没有走索引)





# mysql的RR隔离级别  mysql 隔离级别  选一个你最熟悉的隔离级别说给我听听，详细一点？

# 数据库索引原理

# 聚簇索引和非聚簇索引的区别

# 其他索引(主键索引,普通索引,唯一索引都是干嘛的)  主键索引和普通索引区别

# 除了索引还能怎么优化(sql语句上入手?)  sql语句慢查询如何调优

# B+树索引都能查到叶子节点么

# 底层B+树结构，叶子节点存储的内容  mysql  索引B+树，为什么不用 HashMap  B+，B， AVL， 红黑树区别， 为什么B+， 如果用B会咋样

# mysql两种存储引擎的区别  innodb和myisam的区别
# 如果由大量的增删操作，那么应该选择哪个存储引擎，为什么？
# 事务如何处理的,事务的特性
# 为什么myisam支持事务
# innodb是如何支持的事务
# Mysql为啥用b+树，MongoDB为啥用b树
# innodb索引数据结构，深入问复合主键索引的数据结构是否有不同
# innodb存储引擎中是如何为磁盘io优化的。
# 缓冲区的数据结构是怎样的？
# lru是如何移除和插入数据的？链表中存储的是什么数据，如果没有索引那还存储什么？
# 最左前缀。以及字符串的最左查询  最左前缀匹配的原理,给了一个sql判断是否能走到(会有自动排序,不必按照联合索引顺序写)
    # T（a,b,c,d） index（a,c,d） ， x = a and x = d / x = c and x = a / x = c and x = d
# 为什么数据量大的时候会出现慢sql？
# 慢sql如何解决,如何sql优化。

# 索引数据结构特点和原理 ，一道SQL：查询平均年龄前三的男子的年龄和所在城市

# 数据库了解吗？原子性怎么实现？mvcc的原理？ Innodb， MyISAM，Memory区别。

# 隔离级别

# 分库分表如何做的？分库分表如何不同库表间数据不重复。 分库分表扩容怎么做  如何做到无影响扩容  分库分表是以什么维度来划分的？划分的算法是怎样的，会不会出现数据分配不均衡的情况

# 解决缓存击穿的方式有哪几种?加锁的时候什么时候选择本地锁，什么时候选择分布式锁?

# 数据库主从复制时如何做的？但是如果突然挂掉了，如何保证挂掉那段时间的数据？



# 事务的基本要素
# 事务隔离级别（必考）
# 如何解决事务的并发问题(脏读，幻读)（必考）
# MVCC多版本并发控制（必考）
# binlog,redolog,undolog都是什么，起什么作用
# InnoDB的行锁/表锁
# myisam和innodb的区别，什么时候选择myisam
# 为什么选择B+树作为索引结构（必考）
# 索引B+树的叶子节点都可以存哪些东西（必考）
# 查询在什么时候不走（预期中的）索引（必考）
# sql如何优化
# explain是如何解析sql的
# order by原理
### Mysql常用存储引擎以及应用场景
    - Mysql常用存储引擎Myisam（默认），innoDB
    MyIsam
       - 存储：按顺序存储
       - 事务：不支持事务
       - 行级锁：不支持行级锁，只支持表级锁
       - 外键：不支持外键
       - CRUD：写操作需要锁定整个表，效率低；读取操作执行快
       - 索引：静态索引结构，允许没有任何索引和主键的表存在，索引保存行的地址
    InnoDB：
       - 存储：存储结构为B+树
       - 事务：支持事务
       - 行级锁：支持行级锁
       - 外键：支持外键
       - CRUD：写操作都会给表自动加锁，支持行级锁  ，大幅度提高并发性能
       - 索引：没有主键或者非空唯一索引时，就会自动生成隐藏自增6字节主键作为索引      
           
    1) MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。
    2) InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。大尺寸数据倾向于innodb，因为事务日志和故障恢复
   
### 索引
    - 索引是帮助Mysql快速获取数据的数据结构
    ### 常见索引原则
    1. 选择唯一性索引
    2. 为经常需要排序、分组和联合操作的字段建立索引：
    3．为常作为查询条件的字段建立索引。
    4．限制索引的数目：越多的索引，会使更新表变得很浪费时间。
    5. 尽量使用数据量少的索引
    6．尽量使用前缀来索引：如果索引的值很长，那么查询的速度会受到影响
    7．删除不再使用或者很少使用的索引
    8. 最左前缀匹配原则，非常重要的原则。
    10. 尽量选择区分度高的列作为索引
    11. 索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。
    12. 尽量的扩展索引，不要新建索引
### mysql索引理解，数据结构，优化
    - 索引是帮助Mysql快速获取数据的数据结构
    - Mysql的两种主要的存储引擎的索引的数据结构为B+tree
        - B树是m阶多路平衡查找树
              - 1.树中的每一个节点最多有m个子树
              - 2.除根节点和叶子节点外，其他节点最少有m/2个子节点
              - 3.所有的叶子节点都在同一层
              - 4.节点中的关键字顺序按照升序排列
        - B+树是B树的一种变体
            - 1.B+树非叶子节点不存在数据，只存储索引，每个非叶子节点存储的索引更多，树的层级更小
            - 2.叶子节点包含全部的关键信息，且叶子节点之间通过双向链表进行连接，查询更快
    - MyISAM采用的是索引文件和数据文件分离存储，索引文件采用B+tree存储引擎结构，叶节点的data域存放的是数据的地址，数据文件是顺序存储
    - InnoDB的数据文件本身就是索引文件，数据文件就按照B+tree的结构存储，非叶子节点存储的是主键，叶子节点存储的是完整的数据，这种索引叫做主键索引
        - 非聚集索引（辅助索引）：也采用B+tree存储结构，叶子节点是存储的是主键的值。通过非聚集索引可以找到聚集索引中主键的位置，通过主键的位置可以找到行数据
# 聚簇索引和非聚簇索引的区别
        聚集索引
            - 数据表中数据的物理索引与键值的逻辑索引相同，inonodb中聚集索引就是主键索引，
                如果主键没有定义，该表的第一个唯一非空索引作为聚集索引，否则生成隐藏的6字节自增主键作为聚集索引
            - 一个表只能有一个聚集索引，可以有多个非聚集索引
            - 聚集索引整体是一个B+树，非叶子节点存放的是键值，叶子节点存放的是行数据，叶子之间通过双向链表连接
            - 非聚集索引，叶子节点存的是字段的键值，通过非聚集索引的键值找到对应的聚集索引的键值，再通过聚集索引的键值找到某行的数据
        聚集索引优点：
            1、以最快的速度缩小查询范围。
            2、以最快的速度进行字段排序。
        聚集索引使用场合：
            1、此列包含有限数目的不同值。
            2、查询的结果返回一个区间的值。
            3、查询的结果返回某值相同的大量结果集。
# 索引匹配规则
    - explain：查看sql语句的执行计划   index 全表查询  ref 找符合条件的索引
    - 索引的最左匹配特性：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，b+树会优先比较name来确定下一步的所搜方向
    - 复合索引：复合索引中，mysql优化器会纠正sql以什么样的顺序执行效率会更高，mysql查询优化器最终会以这种顺序进行查询执行

### 数据库的三范式
    - 1.列不可再分解
    - 2.非主属性完全依赖主属性
    - 3.不存在传递依赖

### 事务
    - 属性ACID
      - 原子性 ：要么都执行，要么都不执行
      - 一致性：当事务完成时，数据必须处于一致状态
      - 隔离性：事务之间不互相影响
      - 持久性：事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性
      
### 乐观锁和悲观锁
    - 乐观锁：不加锁，通过时间戳来控制并发出现的问题。每次写数据时，时间戳字段+1，如果比数据库的值大1，就保存，否则不保存
    - 悲观锁: 读写数据的时候都会加锁。SELECT * FROM table_name WHERE ... FOR UPDATE
    
### 数据库锁
    - 行级锁：行级锁是一种排他锁，防止其他事务修改此行
    - 表级锁：对当前操作的整张表加锁，它实现简单，资源消耗较少。分为表共享读锁（共享锁）与表独占写锁 LOCK TABLES t1 WRITE, t2 READ
    - 页级锁：表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录
    共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
    排他锁（X) ：SELECT * FROM table_name WHERE ... FOR UPDATE
    

# 分布式事务(2-3)
    - 事务的属性：
        - 原子性：执行单元中的操作要么全部成功要么全部失败
        - 一致性：操作执行的前后都是完整的
        - 隔离性：事务与事务之间是完全隔离的，只有事务提交后其他事务才可以查询到最新的数据
        - 持久性：事务完成后对数据的改变会完整的存储起来
    - 分布式事务指多个系统通过网络共同完成一个事务，需要保证事务的ACID
        - 例如在下单场景中，库存和订单如果不在一个节点上，就涉及分布式事务
        - 两阶段提交协议（2PC）：由协调者和多个参与者组成，准备阶段和提交阶段，整个过程中，所有参与结点都是阻塞的，协调者故障，参与者会一直阻塞
        
        - 事务补偿（TCC）：A事务执行顺序，那么A事务先提交，B事务执行顺利，B事务提交，整个事务完成，否则B事务回滚，A事务回滚。保证数据最终一致性，灵活性好，开发复杂
            - 保持最终一致性。最终一致性并不需要长时间持有资源的锁，每一个事务其实都是相互独立的，所以tcc的效率会更高
            
        - 基于消息队列的分布式事务（异步确保型）：1.支付成功，本地事务更新订单状态，并向消息表写入减库存 
            2.定时任务扫描消息表，取出减库存消息并发向MQ  
            3.库存端收到消息先检测本地消息表是否有相同消息，存在说明已减库存，否则操作本地数据库减库存，并向本地消息表添加减库存消息，通过本地事务保证，
            4.向MQ发送完成减库存的消息
            5.收到消息后，删除本地消息表的减库存消息，提交事务
            - 本地消息的作用：即使宕机后恢复，确保消息能够被mq接收。做消息的持久化
        - 使用MQ事务消息：Rocketmq支持事务，如果确认消息失败会让发送端回滚。实现最终一致性，不需要依赖本地事务
        
    # cap、 base原则理解
      - cap：分布式系统在设计时只能在一致性(Consistency)、可用性(Availability)、分区容忍性(Partition Tolerance)中满足两种，无法兼顾三种
          - 一致性(Consistency)：多个节点的数据需要保证同一时刻数据的一致性
          - 可用性(Availability)：一个节点宕机不影响整个系统对外提供服务
          - 分区容忍性(Partition Tolerance)：解决由于网络分区导致的数据不完整和无法访问的问题
      - 无法同时兼顾CAP：保持分区容忍性不变的情况下，如果要提高可用性，就要增加多个结点，如果要保持一致性就要实现每个结点的数据一致，结点越多可用性越高，数据一致性越低
          - CA：关系型数据库
          - AP：NoSQL数据库
          - CP：跨行转账
          - 在分布式系统中，AP用得比较多，牺牲实时一致性，保持最终一致性，比如取消订单，退款稍后到帐，事务走完即可
      - base：BA指的是基本业务可用性，支持分区失败，S表示柔性状态，也就是允许短时间内不同步，E表示最终一致性，数据最终是一致的，但是实时是不一致的。
              原子性和持久性必须从根本上保障，为了可用性、性能和服务降级的需要，只有降低一致性和隔离性的要求。


# 内连接
    - MySQL 中内连接是在交叉连接的结果集上返回满足条件的记录
# 外连接
    - 外连接将表分为基表和参考表，更加注重两张表之间的关系，按照连接顺序可以分为左外连接和右外连接
        - 左外连接：匹配左表中的每一行及右表中符合条件的行
# 如何创建联合索引
    - 1.create table ... KEY `sindex` (`aaa`, `bbb`, `ccc`)
    - 2.alter table add index `sindex` (`aaa`, `bbb`, `ccc`)
    - 好处：
        - 减少开销，一条相当于三条
        - 覆盖索引：
        - 效率高:索引列越多，通过索引筛选出的数据越少
# 联合索引的存储结构
    - 联合索引(col1, col2,col3)也是一棵B+Tree，
        其非叶子节点存储的是第一个关键字的索引，
        而叶节点存储的则是三个关键字col1、col2、col3三个关键字的数据，
        且按照col1、col2、col3的顺序进行排序。
     - select的时候，第一列存在，索引能生效，3列都存在，索引全部生效，否则只能部分生效，或者没有第一列不生效
    - 最左前缀原则：
      - 联合索引的B+Tree是按照第一个关键字进行索引排列的，查找的时候直接二分法查找第一列的索引，然后再第二列，再第三列

### where，having
       - where：从数据表中的字段直接进行筛选
       - having：从前面select后筛选的字段再进行筛选
  
### 主从同步(2-2)
    - 主服务器操作数据库记录二进制日志，从服务器根据二进制日志自动执行更新
    - 二进制日志
        - 1.sql语句  2.每一行数据变化的信息  3.混合复制：默认用sql，出问题时用行数据复制
    - 主服务器只要发生变化，立马记录到binary log中
    - 从服务器启动一个thread连接到数据库中，请求Master变化的二进制日志
    - 从服务器获取到二进制日志，保存到自己的relay log中
    - 从服务器有一个SQL thread定期检查relay log是否变化，变化就自动更新
    
    为什么要用主从复制
       - 实现数据的异地备份
       - 实现负载均衡,读写分离
       - 提高数据库系统的可用性
   #### 如何保证主从同步的一致性
       - 1.半同步复制，主库发生增删改操作的时候,会等从库及时复制了并且通知了主库, 才会把这个操作叫做成功，缺点是慢
       - 2.数据库中间件redis：写操作分发到主库，1s内发生相同key的读操作，分发给主库，否则给从库
   #### binlog,redolog,undolog
       Undo 记录某 数据 被修改 前 的值，可以用来在事务失败时进行 rollback；保存的是每行记录逻辑日志，保证事务的原子性
       Redo 记录某 数据块 被修改 后 的值，可以用来恢复已成功事务更新的数据。保存的是物理修改日志，保证事务的持久性
       - binlog 记录的是所有的操作日志记录，在事务最终提交前写入
           - 三种模式
               - statement：记录SQL语句
               - row：记录行变化
               - mix：混合模式
# 读写分离(2-2)
    - 通过Mysql的主从复制结构，可以将读操作分散到从服务器中，并且对从服务器实现负载均衡
    - 问题：主从延迟
        - 从服务器通过主服务器的binary log文件进行同步有1秒的延迟，如果付款后，主库写入数据，但是从库查询不到数据
            - 1.数据库层面：分库，主库拆成读个主库，减小写并发量和同步的延时 2.从库开启多个线程并行复制
            - 2.软件层面：1.使用缓存保存状态，延缓查询时机  2.分配机制：选择不同数据源，关键业务由主库承担，
 
### 分区分表
    - 分库分表有垂直切分和水平切分
    - 垂直切分(按照功能模块)
        - 将表按照功能模块、关系密切程度划分出来， 部署到不同的库上;商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 
    - 水平切分(按照规则划分存储)
        - 当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行
          划分，然后存储到多个结构相同的表，和不同的库上    
    
    #### 分库分表如何不同库表间数据不重复
        - 1.基于uid进行取余分片，数据可以均衡的分配到多个数据库里面
            - 停服迁移：扩容的时候需要停服，修改分片规则，迁移，启动服务。   
            - 升级从库：修改分片配置，从库升级成主库，解除主从关系，冗余数据清理，为新的结点搭建从库
            - 双写迁移：主从同时接收写操作，从库同步主库数据，数据校验，分片规则配置     
# 事务隔离级别(2-2)
    - Read uncommitted读未提交： 一个事务可以读取另一个未提交事务的数据 [脏读]
    - Read committed读已提交：一个事务要等另一个事务提交后才能读取数据，不能防止update，一个事务范围内两个相同的查询却返回了不同数据 [不可重复读]
    - Repeatable read可重复读[默认]：事务开启，不允许其他事务的UPDATE修改操作，两次读取的结果不一致 由insert导致[幻读]：一次事务里，多次查询后，结果集的个数不一致
    - Serializable串行化：事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用
# 幻读解决(2-2)
    - 幻读：一次事务里，多次查询后，结果集的个数不一致
    - 为什么要解决幻读：高并发场景中，要保证事务之间的隔离性和数据的一致性
    - mysql innodb引擎通过MVCC快照读和next-key(当前读)两种模式解决了幻读问题
    - 在快照读读情况下，mysql通过mvcc来避免幻读，简单的select操作
        - MVCC：多版本并发控制。InnoDB为每行记录添加了一个版本号（系统版本号），每当修改数据时，版本号加一；
        在读取事务开始时，系统会给事务一个当前版本号，事务会读取版本号<=当前版本号的数据，这时就算另一个事务插入一个数据，并立马提交，
        新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。
    - 在next-key(当前读)情况下，mysql通过next-key来避免幻读，next-key锁定一个范围的数据再事务提交之前不能变动
    
# B+树(2-3)
    - B树是m阶多路平衡查找树
      - 1.树中的每一个节点最多有m个子树
      - 2.除根节点和叶子节点外，其他节点最少有m/2个子节点
      - 3.所有的叶子节点都在同一层
      - 4.节点中的关键字顺序按照升序排列
    - B+树是B树的一种变体
        - 1.B+树非叶子节点不存在数据，只存储索引，每个非叶子节点存储的索引更多，树的层级更小
        - 2.叶子节点包含全部的关键信息，且叶子节点之间通过双向链表进行连接，查询更快
    # ZK
    - ZooKeeper是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作
    - 服务的注册与发现
    - 心跳检测，集群管理


# 数据库的优化
    - 1.选取最合适的字段属性，数据库的表越小，执行的查询也就越快，因此为了获得更好的性能，将表中字段的宽度设置得尽量的小
    - 2.使用连接（JOIN）来代替子查询(Sub-Queries)：MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作
    - 3.使用联合(UNION)来代替手动创建的临时表。它可以把多个select的查询合并到一个查询中，查询会话结束时，临时表会自动删除，保证数据完整高效
    - 4.事务：使用事务来保证多用户访问同一个数据源时，利用锁定数据库提供一种安全的访问方式。BEGIN;COMMIT;
    - 5.锁定表：事务具有独占性，会影响数据库的性能，可以通过锁定表的方式获取更好的性能
    - 6.使用索引：可以让数据库服务器检索特定行的速度提升，ALTER TABLE或CREATE INDEX创建索引
    - 7.优化查询语句：避免使用!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符.会使得系统无法使用索引，用exists代替in
        - 能够用BETWEEN的就不要用IN
        
    MySQL表字段类型
        - INT，11位宽度
        - TINYINT ，0-255
        - SMALLINT ，65535
        - MEDIUMINT 
        - BIGINT ，20位
        - FLOAT，默认为10,2
        - DOUBLE，默认为16,4
        - DECIMAL
        
        - DATE 日期 YYYY-MM-DD
        - DATETIME 日期和时间 YYYY-MM-DD HH:MM:SS
        - TIMESTAMP 时间戳 YYYYMMDDHHMMSS
        
        - CHAR，固定长度的字符串1-255
        - VARCHAR，可变长度的字符串 
        - ENUM ，枚举
        - BLOB ，二进制大对象，存储图像，65535

# 写一个sql,查询语文成绩前十的学生名字和成绩
    select stuname,coursename,grade,rownum
    from db_student s,db_course c,db_grade g
    where s.stuid=g.stuid and c.courseid=g.courseid
          and rownum<=10 and c.coursename='语文'
    order by grade desc
# sql语句慢查询优化(explain去看有没有走索引)
    借助mysql查询优化器explain，explain会纠正sql语句该以什么样的顺序执行效率最高，
      最后才生成真正的执行计划，观察explain中上述两个sql语句结果的type字段。查询中分别是：
    
    type: index，all 没有用索引，新建组合索引
    type: ref   用了索引，速度还慢，表示索引太多，或者返回数据太多，在sql上设置更多的限制，或者组合索引

# 聚簇索引和非聚簇索引的区别
    在innodb中：
    1.存储：聚簇索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据；非聚簇索引：将数据与索引分开存储，索引结构的叶子节点保存了主键值
    在innodb中，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引
    2.唯一：聚集索引具有唯一性，一个表只有一个聚集索引，有很多非聚集索引
    3.顺序：表中行的物理顺序和索引中行的物理顺序是相同的，在创建任何非聚簇索引之前创建聚簇索引
    4.主键：聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一且非空的索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键（类似oracle中的RowId）来作为聚簇索引
    查找过程
    InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。
    若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据
    
    在MyISAM中：
    1.使用的是非聚集索引，主键索引B+树的节点存储了主键对于行的地址，辅助键索引B+树存储了辅助键对应行的地址，通过辅助键检索无需访问主键的索引树
    
    #### 每次使用辅助索引检索都要经过两次B+树查找，看上去聚簇索引的效率明显要低于非聚簇索引，这不是多此一举吗？聚簇索引的优势在哪？
        - 1.这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快
        - 2.当行数据发生变化时，聚集索引树需要发生分裂变化，避免对辅助索引维护；而且辅助索引叶子结点存放的是主键值，减少了辅助索引占用空间大小
        
    #### 聚集索引需要注意的地方
        - 1.索引字段要尽量的小；主键常用自增ID，不用uuid，uuid占内存，影响IO读取的数据量，自增ID可以保证数据的存放位置和索引顺序是一致的
        - 2.索引的最左匹配特性，b+数是按照从左到右的顺序来建立搜索树的,(a,b,c),必须有a才行，顺序可以调换
        

# 底层B+树结构，叶子节点存储的内容  mysql  索引B+树，为什么不用 HashMap  B+，B， AVL， 红黑树区别， 
    - 1.聚集索引叶子节点存储的是行数据，非聚集索引存储的是主键
    - 2.mysql的B+树索引 查找使用了二分查找，读取io次数和查询次数都比hashmap少
    - 3.b树非叶子节点下面有数据，影响了IO读取的数据量，B+树非叶子节点下面没有数据。
    - 4.红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，
        而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多，
        红黑树降低平衡开销，是对search，insert ，以及delete效率的折衷，总体统计性能高于AVL
    - 5.若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB
### 事务如何处理的,事务的特性 innodb是如何支持的事务
    1.事务的属性
    2.事务的隔离级别
    3.如何处理幻读 mvcc next-key
    
### Mysql为啥用b+树，MongoDB为啥用b树
    - Mysql选用B+树和MongoDB选用B-树还是以自己的需求来选择的
    - b树树内的每个节点都存储数据，叶子节点之间无指针相邻；B+树数据只出现在叶子节点，所有叶子节点增加了一个链指针
    - 因为Mysql是关系型数据库，而Mongodb是非关系型数据，关系型数据库数据遍历多，而非关系型数据库，单一查询比较多，
      B+树子节点之间增加链指针，便于数据遍历；B树非叶子节点有数据域，单一查询的速度快
# lru是如何移除和插入数据的？
    - 使用LinkedHashMap实现，LinkedHashMap底层就是用的HashMap加双链表实现的，新插入和被访问的节点放在表头，删除时从链尾开始
###为什么数据量大的时候会出现慢sql？
    - 如果没有索引或者索引比较多，查询的方案很多，时间也很长
    - 在某个字段或为多个字段建立非聚集索引
    - 加载到内存，作为过渡操作。可通过声明中间虚拟表的方式实现
### 解决缓存击穿的方式有哪几种?
    - 在高并发下,多线程同时查询同一个资源,如果缓存中没有这个资源,那么这些线程都会去数据库查找,对数据库造成极大压力,缓存失去存在的意义
        - 定时刷新更新缓存
     #### 加锁的时候什么时候选择本地锁，什么时候选择分布式锁?
        - 后台服务如果以集群模式存在的话，需要分布式锁
     #### 分布式锁实现方式
         - 使用redis的指令:通常使用setnx方法，incr方法等进行实现
         - 使用zookeeper：使用api生成临时节点实现锁！

### InnoDB的行锁/表锁
    - 行锁必须有索引才能实现，否则会自动变成表锁，会出现死锁，发生锁冲突几率低，并发高
        - 共享锁：允许其他事务并发读，不允许其他事务写  lock in share mode
        - 排它锁：不允许其他事务读写，只允许自己读写  for update
    - 表锁：锁定整张表，不会出现死锁，发生锁冲突几率高，并发低
### explain是如何解析sql的
     表的读取顺序
     数据读取操作的操作类型 type
     哪些索引可以使用
     哪些索引被实际使用
     表之间的引用
     每张表有多少行被优化器查询
### order by原理
    select city,name,age from t where city='杭州' order by name limit 1000 
    - 全字段排序 ： 如果内存够，就要多利用内存，尽量减少磁盘访问
        1.初始化sort_buffer，确定放入name、city、age这三个字段；
        2.从索引city找到第一个满足city='杭州’条件的主键id，也就是图中的ID_X；
        3.到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；
        4.从索引city取下一个记录的主键id；
        5.重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；
        6.对sort_buffer中的数据按照字段name做快速排序；
        7.按照排序结果取前1000行返回给客户端。
     - 创建联合索引（city和name）
         1.从索引(city,name)找到第一个满足city='杭州’条件的主键id；
         2.到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；
         3.从索引city取下一个记录主键id；
         4.重复步骤2、3，直到查到第1000条记录，或者是不满足city='杭州’条件时循环结束。
         
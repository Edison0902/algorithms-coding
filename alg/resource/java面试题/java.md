# Java线程池原理

# 匿名内部类介绍一下，为什么传入的变量要是final的

# volatile关键字的原理和作用，能否保证对共享变量正确控制

# 设计模式常用哪些，三个工厂模式介绍一下

# StingBuilder 和 StringBuffer 的区别

# 死锁的四个条件   死锁3连：你觉得什么是死锁 -》怎么找到死锁 -》 怎么避免死锁

# 进程和线程的区别

# hashmap存一个Person对象,修改对象的某个字段值后还能否查出(我不太确定)

# 单例模式

    写一个单例模式（写了饿汉式）
    如果发生了多并发 同时访问这个单例 会怎么样
    如果不准在静态变量初始化的时候new，要怎么创建这个对象并且保证单例（写了双检锁）
    为什么加volatile？
    enum实现单例会吗（不会）
    
# fianl、finally、finallize

# HashMap， HashTable， ConcurrentHashmap

# Syncronized和reentrantlock的实现原理

# 对类加锁和对实例方法加锁锁的分别是什么(我也是猜的)

# 乐观锁悲观锁和实现

# cookie和session的区别

# cookie跨域可以访问么

# G1不分新生代老年代

# 类加载过程 类加载机制  为什么要引入双亲委派机制

# java泛型原理

# 谈谈对面向对象的理解，谈谈对多态的理解。

# java的虚引用是什么用的？

# 如果一个固定的堆内存，当创建线程数很多的时候，你JVM参数怎么配置

# JVM的最大堆内存和最小堆内村你们项目中是如何配置的，为什么配置成相等的模式。

# 类加载机制，如果我想自己控制类加载的时机怎么办？
##############################
java基础
##############################

# HashMap和ConcurrentHashMap区别（必考）
# ConcurrentHashMap的数据结构（必考）
# 高并发HashMap的环是如何产生的
# volatile作用（必考）
# Atomic类如何保证原子性（CAS操作）（必考）
# synchronized和Lock的区别（必考）
# 为什么要使用线程池（必考）
# 核心线程池ThreadPoolExecutor的参数（必考）
# ThreadPoolExecutor的工作流程（必考）
# 如何控制线程池线程的优先级
# 线程之间如何通信
# Boolean占几个字节
# jdk1.8/jdk1.7都分别新增了哪些特性
# Exception和Error



########################
JVM
########################


# 运行时数据区域（内存模型）（必考）
# 垃圾回收机制（必考）
# 垃圾回收算法（必考）
# Minor GC和Full GC触发条件
# GC中Stop the world（STW）
# 各垃圾回收器的特点及区别
# 双亲委派模型
# JDBC和双亲委派模型关系

#######################

#######################
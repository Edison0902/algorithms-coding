# 状态码以及含义(2-1)
    - 1XX：通知
    - 2XX: 成功
    - 3XX 重定向
    - 4XX：客户端错误：不是认证信息有问题，就是表示格式或HTTP库本身有问题。客户端需要自行改正。
    - 5XX 服务端错误，服务器处于不能执行客户端请求的状态，客户端应稍后重试
    # 转发重定向
     1、转发所涉及的各个web组件可以共享同一个request对象，重定向不可以。
     2、重定向是两次请求，转发是一次请求。
     3、重定向之后，浏览器的网址会变，转发不变
     4、重定向的地址是任意的，转发的地址必须是同一应用中的地址
# 三次握手、四次挥手过程
     第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
     第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
     第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
     - 为了确定自己发送正常，接受正常，对方发送正常，接受正常

# 为什么断开连接需要四次挥手
    • 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
    • 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
    • 服务器-关闭与客户端的连接，发送一个FIN给客户端
    • 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1
    - 为了确定自己发送正常，接受正常，对方发送正常，接受正常
# TCP、UDP区别、应用场景
    - 1.连接：TCP面向连接（在客户端和服务器之间传输数据之前要先建立连接），UDP面向无连接（发送数据之前不需要先建立连接）
    - 2.可靠：TCP提供可靠的服务（通过TCP传输的数据。无差错，不丢失，不重复，且按序到达）；UDP提供面向事务的简单的不可靠的传输
    - 3.数据：TCP是流模式，UDP是数据报模式
    - 4.速度：UDP具有较好的实时性，工作效率比TCP高
    - 5.模式：TCP连接只能是点到点的，UDP支持一对一，一对多和多对多的交互通信
    
# cookie和session的区别
    - 1.存储位置不同。cookie存储在客户端上，session存储在服务器上
    - 2.存储容量不同.单个cookie保存的数据<=4KB,session没有上线
    - 3.存储方式不同：cookie中只能保管ASCII字符串，并转换为二进制数据；session中能够存储任何类型的数据string，integer，list，map
    - 4.隐私策略不同：cookie对客户端可见，不安全。session存放在服务器端，客户端不可见，安全
    - 5.有效性：cookie可以长期有效，session不能长期有效
    - 6.跨域支持上不同：cookie支持跨域名访问；session不支持跨域名访问
# 零拷贝：一种新的数据传输方式
           - 传统数据传输：数据从磁盘读取到内核，从内核拷贝到用户进程，又拷贝回内核，最后通过套接字发送，实际上如果不对文件进行修改的话，中间步骤是不需要做的
           -  零拷贝：内核将磁盘数据直接拷贝到套接字而不再经过用户进程，能较少复制拷贝次数，还能较少上下文切换，缓存污染
    
# osi七层模型，tcp/ip四层模型
    osi七层模型：
        - 物理层：比特流
        - 数据链路层：Mac地址的封装与解封，帧，交换机
        - 网络层：ip地址的封装与解封，数据包，路由器，地址解析协议ARP，IP，网际控制报文协议ICMP
        - 传输层：定义了传输数据的协议和端口，TCP，UDP，段
        - 会话层：发起会话请求或者接收会话请求
        - 表示层：数据的加密解密，压缩与解压缩
        - 应用层：终端应用，FTP,QQ,WEB  HTTP协议
        
    tcp/ip四层模型：
        - 数据链路层  ARP
        - 网络层    ip ICMP
        - 传输层    TCP UDP 
        - 应用层    HTTP
# https 和 http 区别
    HTTPS和HTTP的区别主要如下：
    1、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
    2、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
    3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

#### 对称秘钥加密和非对称秘钥加密  
     - 对称密钥加密，又称私钥加密，即信息的发送方和接收方用同一个密钥去加密和解密数据。
        它的最大优势是加/解密速度快，适合于对大数据量进行加密，但密钥管理困难  
         - AES DES  
     - 非对称密钥加密，又称公钥加密，它需要使用一对密钥来分别完成加密和解密操作，
        信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。
        但加密和解密速度却比对称密钥加密慢得多
        - RSA
    SSL/TLS协议的基本思路是采用公钥加密法
    （1）、如何保证公钥不被篡改？
    解决方法：将公钥放在数字证书中，只要证书是可信的，公钥就是可信的。
    
    SSL/TLS协议的基本过程是这样的：
        1.客户端向服务器端索要并验证公钥。
        2.双方通过非对象加密算法协商生成对称加密算法。
        3.双方采用对称加密进行加密通信。
#### Https的连接过程
    1.客户端发起HTTPS请求
    2.服务端传送数字证书
    3.客户端解析证书，传送公钥加密后的随机值
    4.服务端用私钥解密，得到随机值，把内容通过该值进行对称加密
    5.客户端用私钥解密获得解密内容
##### HTTPS 证书校验过程
    （1）首先浏览器校验证书中的证书所有者、有效期等信息，合法机构颁发
    （4）取出颁发者CA 的公钥对服务器发来的证书里面的签名进行解密
    （5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比
    （6）对比结果一致，则证明服务器发来的证书合法，没有被冒充
    （7）此时浏览器就可以读取证书中的公钥，用于后续加密了
#### post和get的区别
       1、本质区别：get用于查询信息（查），post用于插入信息（插）；
       2、安全性：对于服务器讲，get是安全(不更改信息)、幂等(作用1次和n次效果相同); post不安全、不幂等;   
                           对于客户端将，get参数直接暴露在URL, 不安全；post参数放消息体中，更安全；
       3、传送长度:   get受 URL限制，传送数据量小; post传送数据量大，默认不受限制;    
       4、缓存机制、历史记录：get请求会被浏览器主动缓存，也会被保留在历史记录中，post都不可以；
       5、数据类型：get只允许ASCII码字符类型，post无限制；
       
# tcp如何确保可靠传输（序号，确认，重传，拥塞控制算法）  
    - TCP协议保证传输可靠的方法主要有：校验和，序列号确认应答，超时重传，连接管理，滑动窗口，拥塞控制
    - 1.校验和：判断传输数据是否出现了修改
    - 2.确认应答与序列号,去重
    - 3.超时重传：防止丢包
    - 4.连接管理；保证可靠连接
    - 5.滑动窗口
    - 6.拥塞控制：防止过多的数据注入到网络中，使得路由器过载
        - 1. 慢开始-拥塞控制 2. 快重传-快恢复
        - 慢开始：建立连接时，窗口的大小（cwnd）为1，并且每当接收到一个ACK报文时，cwnd增加到原来的两倍指数型增长，
            直到cwnd到达慢启动的阈值（ssthresh），之后使用拥塞避免算法，cwnd线性增长，每次只增加1线性增长。
            在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，
            慢启动的阈值会变为拥塞窗口的大小的一半，同时拥塞窗口重置为 1
        - 快重传：1. 当发送方连续收到三个重复确认，把慢开始门限ssthresh减半，cwnd值设置为也设为门限值，然后线性增大

# TCP三次握手 为什么要三次（讲了相互协商序列号，还有呢？）
    - 基于tcp协议的双方是双全工的，需要确保自己发送成功，接收成功，对方发送成功，接收成功
    - 通信双方都可以独立关闭自己的通信通道，也就是半关闭
# TCP 四次挥手 tcp四次挥手过程？为什么等待2MSL time_wait
    一、为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。
    二、2MSL时间可以保证本次连接所有报文失效失效，防止“已失效的连接请求报文段”出现在本连接中，避免被服务器端认为是一个新的连接请求

# 登陆态是如何做的,如果禁用cookie，是如何保证登陆态的,token是如何传输的
    - session登录认证方案：用户从客户端传递用户名、密码等信息，服务端认证后将信息存储在session中，将session_id放到cookie中。
      以后访问其他页面，自动从cookie中取到session_id，再从session中取认证信息
    - 将认证信息，返回给客户端，存储到客户端（cookie，或者HTTP 请求的头信息Authorization字段里面）。下次访问其他页面，需要从客户端传递认证信息回服务端
       - 服务器认证以后，生成一个 JSON格式的 对象，发回给客户端，包括用户信息和过期时间



# 输入URL会发生什么
    1.URL的解析：用户输入url，浏览器判断是搜索的话，将搜索内容组合成新的url，如果是url的话，就加上https协议
    2.网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程
    3.DNS域名解析：网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号
    4.三次握手建立TCP连接：
    5.发送HTTP请求
    6.服务器处理请求：发送请求后，服务器响应请求，将数据返回给浏览器
    7.关闭TCP连接
    8.浏览器解析HTML，布局渲染

# 为何OS要分成内核态和用户态
    - 由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 并发送到网络, CPU划分出两个权限等级 – 用户态和内核态

# fork出来的子进程和父进程有哪些共享的东西
    当一个进程fork之后，整个进程表项被复制，包括所有的文件描述符。
      但是文件表项并不会被复制。父进程和子进程共享相同的文件表项

# 交换机是如何工作的
    - 交换机通电后会自动建立一个端口地址表，也叫MAC地址表它会记录每个设备的MAC地址机和哪个端口连接的
    - 交换机收到一个以太帧数据，它自己会比对交换机已经学习到的端口地址表，如果表里存在端口地址，直接在对应的端口转发出去。
          如果表里不存在，则会向剩下的每个端口（除送信息过来的端口）广播发送一条相同的信息。

# 状态码以及含义(2-1)
    - 1XX：通知
    - 2XX: 成功
    - 3XX 重定向
    - 4XX：客户端错误：不是认证信息有问题，就是表示格式或HTTP库本身有问题。客户端需要自行改正。
    - 5XX 服务端错误，服务器处于不能执行客户端请求的状态，客户端应稍后重试
    # 转发重定向
     1、转发所涉及的各个web组件可以共享同一个request对象，重定向不可以。
     2、重定向是两次请求，转发是一次请求。
     3、重定向之后，浏览器的网址会变，转发不变
     4、重定向的地址是任意的，转发的地址必须是同一应用中的地址
# 三次握手、四次挥手过程
     第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
     第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
     第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
     - 为了确定自己发送正常，接受正常，对方发送正常，接受正常

# 为什么断开连接需要四次挥手
    • 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
    • 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
    • 服务器-关闭与客户端的连接，发送一个FIN给客户端
    • 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1
    - 为了确定自己发送正常，接受正常，对方发送正常，接受正常
# TCP、UDP区别、应用场景
    - 1.连接：TCP面向连接（在客户端和服务器之间传输数据之前要先建立连接），UDP面向无连接（发送数据之前不需要先建立连接）
    - 2.可靠：TCP提供可靠的服务（通过TCP传输的数据。无差错，不丢失，不重复，且按序到达）；UDP提供面向事务的简单的不可靠的传输
    - 3.数据：TCP是流模式，UDP是数据报模式
    - 4.速度：UDP具有较好的实时性，工作效率比TCP高
    - 5.模式：TCP连接只能是点到点的，UDP支持一对一，一对多和多对多的交互通信
# cookie和session的区别

# cookie跨域可以访问么
# 零拷贝：一种新的数据传输方式
           - 传统数据传输：数据从磁盘读取到内核，从内核拷贝到用户进程，又拷贝回内核，最后通过套接字发送，实际上如果不对文件进行修改的话，中间步骤是不需要做的
           -  零拷贝：内核将磁盘数据直接拷贝到套接字而不再经过应用，能较少复制拷贝次数，还能较少上下文切换，缓存污染
    
# tcp如何确保可靠传输（序号，确认，重传，拥塞控制算法）  拥塞控制的算法有哪几种？慢开始前期是指数型增长还是线性增长？
# TCP三次握手 为什么要三次（讲了相互协商序列号，还有呢？）
# TCP 四次挥手 tcp四次挥手过程？为什么等待2MSL
# 四次挥手，time_wait的原因，post和put的区别，各种请求头的意义

# cookie和session的区别。
# 登陆太是如何做的,如果禁用cookie，是如何保证登陆太的,token是如何传输的

# https 和 http 区别
# 网络中http头字段有哪些,post和get的区别
# HTTPS 证书校验过程

# 输入URL会发生什么

# TCP,UDP区别
# 游戏里大多用udp，问我为什么要用udp
# 影响tcp传输速度的因素有哪些
# linux操作系统

# 为何OS要分成内核态和用户态

# 网络分层，分层的目的，每一层是干啥的，有哪些协议
# osi七层模型，tcp/ip四层模型
# 数据链路层详细介绍
# fork出来的子进程和父进程有哪些共享的东西

# 浏览器输入网址回车后发生什么

# 交换机是如何工作的

# get和post区别


# 对称加密算法和非堆成加密算法
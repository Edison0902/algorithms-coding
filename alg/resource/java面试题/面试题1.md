# Java基础

## JAVA volatile关键字以及线程安全;(2-1)   不同等级的深度,扩展;    
    1.Java的线程安全问题 （主内存，工作内存） 		   
      - Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。
	 由于java中的每个线程有自己的工作空间，这种工作空间相当于上面所说的高速缓存，因此多个线程在处理一个共享变量的时候，就会出现线程安全问题。

    2.volatile保证变量可见性的原理
      - volatile  在多线程环境下，某个共享变量如果被其中一个线程给修改了，其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的工作空间中读取
	  - 当一个变量被声明为volatile时，在编译成会变指令的时候，会多出下面一行
	0x00bbacde: lock add1 $0x0,(%esp);  这条指令的前面有一个lock(锁)前缀，在寄存器执行一个加0的空操作
	处理器遇到lock指令时不会再锁住总线，而是会检查数据所在的内存区域，如果该数据是在处理器的内部缓存中，则会锁定此缓存区域，处理完后把缓存写回到主存中，并且会利用缓存一致性协议来保证其他处理器中的缓存数据的一致性

      - 缓存一致性协议：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。
	线程中的处理器会一直在总线上嗅探其内部缓存中的内存地址在其他处理器的操作情况，一旦嗅探到某处处理器打算修改其内存地址中的值，而该内存地址刚好也在自己的内部缓存中，那么处理器就会强制让自己对该缓存地址的无效。所以当该处理器要访问该数据的时候，由于发现自己缓存的数据无效了，就会去主存中访问

    有序性
	  - 当我们把代码写好之后，虚拟机不一定会按照我们写的代码的顺序来执行
	    虚拟机在进行代码编译优化的时候，对于那些改变顺序之后不会对最终变量的值造成影响的代码，是有可能将他们进行重排序的
	    对于有些代码进行重排序之后，虽然对变量的值没有造成影响，但有可能会出现线程安全问题的
	    如果一个变量被声明volatile的话，那么这个变量不会被进行重排序，也就是说，虚拟机会保证这个变量之前的代码一定会比它先执行，而之后的代码一定会比它慢执行

    - 什么情况下volatile能够保证线程安全
	   - 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
	   - 变量不需要与其他状态变量共同参与不变约束。


# ArrayList默认大小,以及空间扩展方法 (2-1)   
    - 1.不指定ArrayList的初始容量，在第一次add的时候会把容量初始化为10个，这个数值是确定的；
    - 2.ArrayList的扩容时机为add的时候容量不足，扩容的后的大小为原来的1.5倍，扩容需要拷贝以前数组的所有元素到新数组
    - 3.ArrayList是动态增长的数组，grow（）计算出新的扩容数组的size后实例化，并将原有数组内容Arrays.copyOf复制到新数组中去

# 泛型原理,常见集合类 (2-1)
    - 泛型：本质是类型的参数化，将所操作的数据类型指定为一个参数，参数类型可以用来类、方法、Map接口、集合中
    - 原理：泛型只存在于编译阶段,而不存在于运行阶段，编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率
    - 应用场景：类、方法、Map、集合
    - 通配符：? extends A 设置上限  ? super A  设置下限；泛型必须匹配才可以传递，否则无法传递
  
  ### 常见集合
      - List
      - Set
      - Queue
      - Map
# 内存划分: java 栈,堆,方法区等;(2-2)
 
    - java内存区域:
     - 虚拟机栈     （线程私有）   存储局部变量表、操作数栈、动态链接、方法出口等信息
	 - 本地方法栈   （线程私有）   存放着虚拟机使用到的Native方法服务
	 - 程序计数器 （线程私有）    记录的是正在执行的虚拟机字节码指令的地址
	 - 方法区    （线程共享）     内存中最大的一块，共享区域，类信息，常量信息，静态变量
	 - 堆      （线程共享）       内存中最大的一块，共享区域，保存对象实例以及数组，垃圾收集器进行垃圾收集的主要区域
	 - 本地内存：  不受JVM GC管理
	 

# HashMap原理, 冲突解决(2-2)
     HashMap基于Map接口实现，元素以键值对的方式存储，允许null键和null值，key不许重复，只允许一个null键，无序的不能保证放入元素的顺序，初始化大小16，负载因子0.75
	 hashmap与hashtable
	     1.线程安全：Hashtable是线程安全，而HashMap则非线程安全
		 2.针对null：HashMap可以使用null作为key，而Hashtable则不允许null作为key
		 3.继承结构：HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类
		 4.扩容大小：HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75
		             - HashMap扩容时是当前容量翻倍即:capacity*2，Hashtable扩容时是容量翻倍+1即:capacity*2+1
		 5.两者计算hash的方法不同：Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模
		                           HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸
								   
	HashMap是jdk1.7数组和链表的结构；1.8数组+链表+红黑树
	    put：添加键值对时，首先进行table是否初始化的判断，如果没有进行初始化（分配空间，Entry[]数组的长度16）。然后进行key是否为null的判断，如果key==null ,放置在Entry[]的0号位置。计算在Entry[]数组的存储位置，判断该位置上是否已有元素，如果已经有元素存在，则遍历该Entry[]数组位置上的单链表。判断key是否存在，如果key已经存在，则用新的value值，替换点旧的value值，并将旧的value值返回。如果key不存在于HashMap中，程序继续向下执行。将key-vlaue, 生成Entry实体，添加到HashMap中的Entry[]数组链表的尾部jdk1.8
	冲突解决：
	    - 线性（平方\随机）探测再散列法
		- 再散列法
		- 链地址法：将链表的头结点存在hash数组中，适用于经常插入和删除
		
# 强引用，弱引用，软引用，虚引用(2-3)
    - 把对象的引用分为4种级别，更加灵活的控制对象的生命周期
    - 强引用：[new] 垃圾回收器不会回收它，当内存不足的时候，会抛出OOM，程序终止
    - 软引用：如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存
        - 场景：实现内存敏感的高速缓存；1.例如浏览器的后退按钮，将浏览过的网页存储到存入软引用，
        取数据时就可从内存里取数据，提高运行效率，内存不足的是时候会自动清除软引用，避免造成内存溢出
        - 2.假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。
        如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软引用技术来避免这个问题发生
    - 弱引用：垃圾回收器线程扫描内存中只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存
        - 场景：等同于软引用，生命周期更短，不影响垃圾回收
    - 虚引用：虚引用并不会决定对象的生命周期，任何时候都可以被垃圾回收。
        - 场景：主要用来跟踪对象被垃圾回收的活动。虚引用必须和引用队列（ReferenceQueue）联合使用
# ArrayBlockingQueue(2-2)
    - ArrayBlockingQueue：基于数组的阻塞队列，读写共享一个锁，吞吐量小，先进先出有界队列，不会OOM
    - LinkedBlockingQueue：基于链表的组赛队列，读写各有一个锁，吞吐量大，无界队列，内存浪费
    - add remove 异常
    - offer poll false null
    - put take 阻塞
    
#JVM垃圾回收算法,   CMS G1 等, 特性, fullGC,(2-3)
     java堆从GC的角度细分为：新生代1/3（Eden8/10，from1/10，to survivor1/10）和老年代2/3
	     - 新生代：用来存放新生的对象，由于频繁创建，所以新生代会频繁触发MinorGC，默认年龄15的对象会被移到老年代
		     - Eden：Java新对象的出生地。如果对象占用内存很大，直接分配到老年代，内存不够进行MinorGC，对新生代进行一次垃圾回收
	         - MinorGC采用复制算法：（复制-清空-互换）把eden和from中存活的对象保存到to中，同时把年龄+1，清空eden和from，将from和to互换
		 - 老年代：存放生命周期长的对象，不会频繁GC。内存不足MajorGC
		     - MajorGC：采用标记清除算法，扫描一次老年代，标记存活的对象，回收没有标记的对象。耗时长会产生内存碎片
			 - Full GC 是清理整个堆空间—包括年轻代和永久代
	     - 永久代：存放Class和Meta信息，GC不会在主程序运行期对永久区域进行清理
		 - JAVA8元数据：永久代已经被元空间取代，保存到java内存中，不受MaxPermSize控制，由系统实际可用空间控制；字符串池和类的常量信息放入java堆中
		 
		 - 如何确定是垃圾？
		     - 引用计数：通过引用计数来判断对象是否会回收，会产生循环计数问题
			 - 可达性分析：通过GC ROOT作为起点搜索，如果对象和gc root之间没有可达路径，则称该对象是不可达的；不可达对象经过两次标记仍是可回收对象，则面临回收
	     - 垃圾回收算法
		     - 标记清除：耗时长会产生内存碎片
			 - 复制算法：每次只使用一块内存，把存活的对象复制到另一块内存中去，把已经使用的内存清除掉
			 - 标记整理算法：标记后不是清理对象，将存活对象向内存一端移动，清除端边界外的对象
			 - 分代收集算法：新生代每次都有大量垃圾要回收，复制算法；老年代每次只有少量垃圾要回收，标记整理算法

         - CMS：多线程标记清除算法
		     - Concurrent mark sweep 是一种老年代垃圾收集器，主要目的是获取最短垃圾回收停顿时间，和标记整理算法不同，使用多线程的标记清除算法，最短的垃圾收集停顿时间，提供用户体验
			     - 初始标记：暂停所有工作线程：标记GC ROOT能直接关联的对象，速度很快
				 - 并发标记：不需要暂停工作线程：进行GC Root跟踪过程，和用户线程一起工作
				 - 重新标记：暂停所有工作线程：修正因程序继续运行导致标记变动的部分对象记录
				 - 并发清除：不需要暂停工作线程：清除GC Root不可达对象，和用户线程一起工作
		 - G1：避免全区域垃圾收集，把堆内存划分为大小固定的几个独立区域，跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。
		        区域划分和优先级区域回收机制，确保G1垃圾收集器可以在有限的时间获得最高的垃圾回收效率
             1.基于标记整理算法，不产生内存碎片
			 2.可以非常精确的控制停顿时间，在不影响吞吐量的前提下，实现低停顿垃圾回收
# 多线程

 ## 线程同步, sleep wait (2-2)
     - 线程的状态 new runable running blocked dead
     - sleep 释放cpu时间片段，不释放锁
     - wait 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法
     - yeild 线程让步，主动让出CPU执行权，让其他线程也有相同的cpu优先级

 ## 可重入锁, synchronized 与lock 不同(2-2)
     不可重入锁：只判断这个锁有没有被锁上，只要被锁上申请锁的线程都会被要求等待。实现简单
     可重入锁：不仅判断锁有没有被锁上，还会判断锁是谁锁上的，当就是自己锁上的时候，那么他依旧可以再次访问临界资源，并把加锁次数加一。
         1.同一线程外层函数获得对象锁之后，内层递归函数仍然可以获取该对象锁的代码，而不会出现死锁  synchronized  ReentrantLock
	 作用及使用场景：
	     1.最大的作用就是可以避免死锁
		 2.当一个线程执行一个带锁的代码块或方法，代码块或方法里也获取同一个锁。为了避免死锁，可以用可重入锁。
	 相同点:两种方法在加锁和内存上提供相同的语义	
	 不同点：

     1.用法不一样，synchronized加在方法和特定的代码块上，lock需要显示的指定起始位置和结束位置；synchronized托管给JVM执行，lock通过代码执行
	 2.性能不一样，lock不仅拥有和synchronized相同的并发性，还增加了定时的锁等待、可中断的锁等待、公平与非公平锁。在资源竞争不激烈情况下，synchronized的性能要优于ReentrantLock，带在资源紧张很激烈的情况下，synchronized的性能会下降的很快，而ReentrantLock的性能基本保持不变
	 3.锁机制不一样。synchronized获得锁和释放锁的机制都在代码块结构中，当获得锁时，必须以相反的机制去释放，
	 并且自动解锁，不会因为异常导致没有被释放而导致死锁。而Lock需要开发人员手动去释放，并且写在finally代码块中，否则会可能引起死锁问题的发生。此外，Lock还提供的更强大的功能，可以通过tryLock的方式采用非阻塞的方式取获得锁。
	 
 # concurrentHashMap等线程优化集合;(2-2)
     jdk1.7中是采用Segment + HashEntry + ReentrantLock
	 jdk1.8中是采用Node + CAS + Synchronized
	 JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）
     JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档

	 用volatile修饰的Node
	     - 为了使得Node数组在扩容的时候对其他线程具有可见性而加的volatile
		 - get操作全程不需要加锁是因为Node的成员val是用volatile修饰的
     
     - 链表转换成红黑树的情况：1.数组长度大于等于64  2.单链表长度大于8
         - 红黑树是一颗弱平衡的二叉搜索树
         - 每个节点要么是黑色，要么是红色。
           根节点是黑色。
           每个叶子节点（NIL）是黑色。
           每个红色结点的两个子结点一定都是黑色。
           任意一结点到每个叶子结点的路径都包含数量相同的黑结点。
      - sizeCtl: -1表示初始化   -(1+n) n:表示活动的扩张线程  在实例化对象的时候指定了容量，则初始化sizeCtl=len*0.75 控制表初始化
      - 初始化数组table
          - 第一次put的时候，table还没被初始化，进入while
          - sizeCtl初始值为0，当小于0的时候表示在别的线程在初始化表或扩展表，让出yield
          - 否则cas修改sizeCtl的值
          - 指定了大小的时候就创建指定大小的Node数组，否则创建指定大小(16)的Node数组
          - 初始化后，sizeCtl长度为数组长度的3/4
      - putVal
          - 初始化：当添加一对键值对的时候，首先会去判断保存这些键值对的数组是不是初始化了，如果没有的话就初始化数组
          - 空：然后通过计算hash值来确定放在数组的哪个位置，如果这个位置为空则直接添加，如果不为空的话，则取出这个节点来
          - 扩容：如果取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容，复制到新的数组，则当前线程也去帮助复制
          - 加锁遍历：最后一种情况就是，如果这个节点，不为空，也不在扩容，则通过synchronized来加锁，进行添加操作，然后判断当前取出的节点位置存放的是链表还是树
          - 链表：如果是链表的话，则遍历整个链表，直到取出来的节点的key来个要放的key进行比较，如果key相等，并且key的hash值也相等的话，则说明是同一个key，则覆盖掉value，否则的话则添加到链表的末尾
          - 树：如果是树的话，则调用putTreeVal方法把这个元素添加到树中去
          - 扩容：最后在添加完成之后，会判断在该节点处共有多少个节点，不加当前节点大于等于8个的话
            则调用treeifyBin方法来尝试将处的链表转为树，或者扩容数组
          
       - treeifyBin
           - 当数组长度小于64的时候，扩张数组长度一倍，否则的话使用synchronized同步器，将该节点出的链表转为树
       - tryPresize:扩容表为可以容纳指定个数的大小（总是2的N次方），并没有加锁，允许多个线程进入，如果数组正在扩张，则当前线程也去帮助扩容
           - transfer
               - 1.将表拆分，让每个线程处理自己的区间，最小区间为16
               - 2.扩容的时候每处理一个节点，会在链表的头部设置一个fwd节点，这样其他线程就会跳过他
               - 3.根据节点的hash值判断Node在新表中的位置，0：新表的原来位置  n：新表的n+原来位置
               - 顺序大部分和原来是反的，分成两部分分别放到了原来的位置和新增加的长度的相同位置
       - get
           - 当key为null的时候回抛出NullPointerException的异常
           - get操作通过首先计算key的hash值来确定该元素放在数组的哪个位置
           - 然后遍历该位置的所有节点

# threadlocal(2-2)
    - 线程局部变量
        - 每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。
        - ThreadLocal相当于维护了一个map，key就是当前的线程，value就是需要存储的对象
        - spring声明式事务的重要实现基础就是ThreadLocal
        - 内存泄漏
            - ThreadLocal引用被设置为null，且后面没有set，get,remove操作。
              ②线程一直运行，不停止。（线程池）
              ③触发了垃圾回收。（Minor GC或Full GC）

# JAVA线程池类型,特性 coresize maxsize (2-3)

# 线程数量如何判断,衡量方法(2-3)
    1、针对IO密集型的，阻塞耗时w一般都是计算耗时几倍c，假设阻塞耗时=计算耗时的情况下，Nthreads=Ncpu*(1+1)=2Ncpu,所以这种情况下，建议考虑2倍的CPU核心数做为线程数
    2、对于计算密集型的，阻塞耗时趋于0，即w/c趋于0，公式Nthreads = Ncpu+1。
# OOP设计模式

# 单例 模式 线程安全,延迟初始化(2-1)
    - 1. 懒汉模式（线程不安全）(懒加载)
    - 2. 线程安全的懒汉模式（线程安全）效率低
    - 3. 饿汉模式（线程安全）（无懒加载）
    - 4. 静态类内部加载（线程安全）静态内部类不会在单例加载时就加载，而是在调用getInstance()方法时才进行加载，达到了懒加载的效果，而这种方法又是线程安全的
    - 5. 枚举方法（线程安全）(可序列化)（懒加载）

```java
static enum SingletonEnum{
        //创建一个枚举对象，该对象天生为单例
        INSTANCE;
        private User user;
        //私有化枚举的构造函数
        private SingletonEnum(){
            user=new User();
        }
        public User getInstnce(){
            return user;
        }
    }
```
    - 6.双重校验锁法+volatile

# 工厂抽象工厂(2-2)
      - 简单工厂方法：一个工厂生产所有产品
      - 工厂方法：每个产品都有一个专属工厂，避免工厂类变成超级类（一个工厂生成所有对象）
      - 抽象工厂：同类工厂中抽象出工厂接口，具体工厂实现继承抽象工厂；只能横向扩展同类工厂
# 发布订阅模式(2-2)
      - 在被观察者Subject中注册添加观察者Observer
      - 发送通知时：被观察者调用观察者的update方法，更新通知
# 模板方法(2-1)
    - 定义一个抽象基类，创建一个final类型的算法框架和多个抽象方法
    - 子类继承抽象基类，实现抽象方法；使用的时候只要调用算法框架即可
# 桥接方法(2-2)
    - 将抽象部分与它的实现部分分离，使抽象部分和具体部分都可以独立地扩展
    - JDBC驱动器；JDBC为所有的关系型数据库提供一个通用的界面。一个应用系统动态地选择一个合适的驱动器，然后通过驱动器向数据库引擎发出指令。这个过程就是将抽象角色的行为委派给实现角色的过程。
# 装饰器模式(2-2)
    - 对已经存在的某些类进行装饰，扩展一些功能
    - 包装类和被包装类实现同一个接口，包装类在被包装类的基础上扩展功能，不影响被包装类
    - InputStream作为一个普通类，有多个具体装饰器比如BufferedInputStream、DataInputStream等
# Redis MemoryCache对比
    1.memcached所有的值均是简单的字符串，redis支持更丰富的数据类型
    2.Redis的速度比memcached快很多
    3.Redis可以持久化和事务
    
# Redis数据类型,以及底层实现, 单线程/多线程模型?(2-1)
    1.string：最基本的数据类型，二进制安全的字符串，512M。
    2.list：按照添加顺序保持顺序的字符串列表。2^32 - 1
    3.set：无序的字符串集合，不存在重复的元素。2^32 - 1
    4.sorted set：已排序的字符串集合。2^32 - 1
    5.hash：key-value对的一种集合。 2^32 - 1
    
    redis优势：
    1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
    2. 支持丰富数据类型，支持string，list，set，sorted set，hash
    3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
    4. 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除
    
    单线程：
       - redis是基于内存的，CPU不是其瓶颈，瓶颈可能是内存或者网络带宽，单线程实现容易，避免锁的性能消耗，减少上下文切换时间
    IO多路复用：
       - 多个socket复用一个线程，多路IO复用计数可以让单线程高效的处理多个请求
    单点吞吐量
       - QPS：应用系统每秒钟能接受的最大用户访问量：10万/s （单个接口一个处理）
       - TPS：每秒最大请求数；8万 （一个请求对应多个处理） 
    哈希槽：
       - Redis集群没有使用一致性hash,而是引入了哈希槽的概念，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中
    场景：
       - session共享
       - 页面缓存
       - 计数器
    分布式锁：redis 在2.6.12版本 同时设置kv和过期时间  SET key value [EX seconds] [PX millisecounds] [NX|XX]
    
    redis+lua:1.性能  2.原子性
        - 1.所需要秒杀商品 及库存数据推到redis
        - 2.使用lua编写相应的脚本，放到redis去执行，返回0表示已秒过，返回2库存不足，返回1扣库存成功
        - lua ： 利用lua脚本淘汰用户，解决超卖问题
          - 1.用户是否已经秒过商品
          - 2.校验库存
          - 3.扣库存
          - 4.设置抢单成功
          - 5.返回结果

    - 在巨大的数据量的情况下，做类似于查找符合某种规则的Key的信息
        - 是keys命令，keys命令是以阻塞的方式执行的，keys是以遍历的方式实现的复杂度是 O(n），Redis库中的key越多，查找实现代价越大，产生的阻塞时间越长。keys key1111*
        - 是scan命令，以非阻塞的方式实现key值的查找，有一定的重复概率，客户端再做去重，时间较长。scan 0 match key1111* count 20

    - Redis做异步队列
      - list作为消息队列，rpush生产消息，lpop消费消息，当lpop没有消息的时候，适当sleep一会儿再重试，或者blpop阻塞
      - pub/sub主题订阅者模式，可以实现1:N的消息队列，在消费者下线的情况下，生产的消息会丢失
      - 延时队列：使用sortedset，拿时间戳作为score，消息内容作为key，调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理
# 主从同步方式(2-2)
    哨兵（Sentinel）和复制（Replication）
      - Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能。高可用
      - Replication主从同步（复制）。扩展性
          - 一个主服务器可以有多个从服务器，从服务器也可以有自己的从服务器
          - 异步复制原理；从服务器向主服务器发送一个SYNC命令，主服务器将开始执行 BGSAVE，将所有的新操作命令保存到缓存区域，然后将保存的.rdb文件发给从服务器，从服务器接收到这个文件，将数据载入到内存中
    事务
      - 支持一次性按顺序执行多个命令的能力，并保证其原子性
    LUA脚本
      - 在服务端一次性的执行更复杂的操作（包含一些逻辑判断）
    持久化
      - redis会把内存的中的数据写入到硬盘中，在redis重新启动的时候加载这些数据，从而最大限度的降低缓存丢失带来的影响。
          - RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储
          - AOF持久化方式以日志的形式记录每个写操作，AOF文件的体积不至于过大
          - AOF文件保存的数据集要比RDB文件保存的数据集要完整，数据恢复Redis会优先选择AOF恢复，RDB恢复数据集的速度要快很多
    Java客户端：Redisson、Jedis
# Redis内存管理(2-2)
    对于过期数据的删除
      - 下次查询时，检查key超时时间，，已超时则删除数据
      - 定时任务，默认每10秒一次，检查超时时间，超时删除

# 缓存击穿以及雪崩防止; 布隆过滤器方式(2-3)
    - 缓存穿透，是指查询一个数据库一定不存在的数据。每次查询都是空，每次又不进行缓存，容易压垮数据库。redis采用缓存空值的方法
    - 缓存雪崩：在某一段时间内，缓存集中过期失效。不同分类的商品缓存不同的周期，热点商品缓存长，冷门商品缓存短
    
    - 布隆过滤器：布隆过滤器是一个 bit 数组，特点是高效的插入和查询，缺点是返回的结果是概率性的
        - 使用多个hash函数生成多个hash值，对每一个hash值指向的bit位置为1。查询时，如果指定的位置不为1，肯定不存在；如果全部为1，可能存在
        - Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。
          但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。
          拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，
          而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上
          
# Spring

# AOP原理(2-1)

# springmvc control 单里还是多例(2-1)

# SpringMVC请求处理流程(2-1)

# Spring 动态代理(2-2)

# 拦截器过滤器区别(2-2)

# MYSQL 

# 聚簇索引与非聚簇索引(2-1)

# 表格存储引擎innoDB Mysiam(2-1)

# 主从同步(2-2)

# 读写分离(2-2)

# 事务隔离级别(2-2)

# 幻读解决(2-2)

# B+树(2-3)

# ZK

# 分布式锁, 节点类型 (2-2)

# RPC&SOA

# 服务治理,限流监控,降级,熔断等(2-3)

# 分布式事务(2-3)

# HTTP

# 状态码以及含义(2-1)

# 编程&&算法

# 生产者消费者模型 (2-1)

# 三个有序数组合并(2-1)

# 链表翻转 (2-1)

# 二叉树分层&&深度遍历(2-2)

# 一致性hash (2-2)

# 经典活动安排 (2-2)

# 最大连续子数组的和 (2-2)

# int数组分为两个和最接近的子集 (2-3)

# Nginx负载均衡

# 常见策略; (2-2)

# 架构题目

# 设计一个计算最大质数的服务; (2-3)
 
 
# 网络

# 三次握手、四次挥手过程

# 为什么断开连接需要四次挥手

# TCP、UDP区别、应用场景

# 数据结构

# HashMap的实现原理

# HashMap数据结构？

# HashMap源码理解

# ConcurrentHashMap的实现原理

# 二叉树



# 算法

# 手写链表逆序代码

# 判断单项链表是否有环

# 一个数组里面所有数字都出现两次，只有一个（两次）数字出现一次，找出这个（两个）数字

# 手写快排



# 多线程

# volatile原理、作用

# ReentrantLock 、synchronized和volatile比较

# 对NIO、AIO的理解

# jvm相关

# Jvm内存模型

# 垃圾回收过程

# 如何判断对象已死，GC Roots有哪些

# 常见垃圾回收器及理解

# 数据库

# 数据库的优化

# mysql索引理解

# Mysql常用存储引擎以及应用场景

# 聚簇索引和非聚簇索引的区别

# Mysql索引数据结构及优化

# 索引匹配规则

# 基础组件

# redis与mamcache有什么不同

# zookeeper选举过程

# kafka原理

# kafka如何保证大吞吐量、高性能

# 分布式

# cap、 base原则理解

# 分布式是服务实现

# 一致性hash
1.两数之和  双指针
2.最大子序列和  preMax = Math.max(preMax, preMax+num);   res = Math.max(res, preMax);
3.合并两个有序链表  while遍历链表，对比l1和l2，将小的连接到node上，最后返回head.next
4.无重复字符的最长子串  Map<Character,Integer>  字符及其出现的位置  保存最大不重复字符出现的位置  保存最长子串 保存字符出现的位置
5.寻找两个有序数组的中位数   保存到有序数组中 然后求中位数
6.螺旋矩阵    matrix[r1][c] [c1 - c2]  matrix[r][c2] [r1+1 - r2]  matrix[r2][c] [c2-1 - c1)  matrix[r][c1] [r2 - r1)
7.合并两个有序数组  排序+贪心算法
8.反转链表  ListNode next = cur.next  cur.next = next.next;  next.next = pre.next; pre.next = next;
9.两数相加    carry = sum / 10;
10.整数反转  ans = ans * 10 + pop
11.子集       res.add(new ArrayList<>(list));  dfs(res,list,nums,i+1);
12.搜索旋转排序数组  二分法 + 鉴别递增区间
13.字符串转换整数  1.跳过空字符 2.判断数字的符号 3.找出数字部分 4.溢出判断
14.爬楼梯  dp dp[i] = dp[i-1] + dp[i-2];
15.二叉树中的最大路径和   递归 ret = Math.max(ret, r.val + left + right);   Math.max(left, right) + r.val;
16.全排列    回溯算法 list.add(nums[i]);
17.最小路径和     逆序两层for循环 当前节点的值只与当前节点和min(左下节点和右下节点)有关  grid[i][j] = grid[i][j] + Math.min(grid[i + 1][j], grid[i][j + 1]);
18.最长回文子串  dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 2 || dp[i + 1][j - 1]);
19.火星词典  拓扑排序
20.三数之和  双指针

21.不同路径   dp dp[i][j] = dp[i-1][j] + dp[i][j - 1]
21.合并区间      Arrays.sort Comparator compare while start end  list.toArray(new int[list.size()][2])
22.有效的括号    stack push pop
23.环形链表      slow = head fast = head.next 快慢指针
24.全排列        backtrace(nums, start + 1, end, res)
25.不同路径||    动态规划：obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
26.打印零与奇偶数    Semaphore
27.螺旋矩阵||    迭代条件 装载数据 更新边界
28.盛最多水的容器   双指针法，移动较小高度的指针
29.有效的数独    boolean[][] row col block 记录某行列网格中是否出现过该数
30.三角形最小路径和  dp[j] 长度为j的最小路径和 = 下一层相邻的最小路径 + 当前路径
31.数组中的第K个最大元素  维护一个小根堆，小根堆保存k个最大的元素
32.验证二叉搜索树    中序遍历保证从小到大
33.二叉树的最大深度  递归：左右子树的最大深度+1
34.买卖股票的最佳时机  迭代每个价格，当前值减去历史最小值 最大值即为最大利润
35.最大正方形    动态规划 Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;  Math.min(Math.min(dp[j - 1], prev),dp[j]) + 1;
36.LRU缓存机制   LinkedHashMap 调用super方法  || hash表+双向链表    如果容量满了要删除最后一个数据队尾；数据访问通过hash表查找，每次访问还要把数据插入到队头
37.二叉树的层次遍历    队列保留每一层的TreeNode
38.最大矩形         dp[j] = matrix[i][j] == '1' ? dp[j] + 1 : 0; + 柱状图中的最大面积
39.用栈实现队列     将两个栈组合起来 数据进出push和pop

40.划分字母区间     数组：保留每个字符最后出现的位置  && 当字符的最大位置和索引值一致时，保存长度
41.二叉树的最近公共祖先    递归，如果发现左右子树都在该节点下，返回该节点；或者返回左右不为空的节点
42.最长重复子数组    动态规划dp[i][j] 前缀为A[i:]B[j:]最长重复子数组   二层遍历  状态转移 if(A[i-1] == B[j-1]) dp[i][j] = dp[i-1][j-1] + 1 max(dp[i][j])
43.合并K个排序链表    优先队列  链表dummy
44.解码方法      int[] dp = new int[2]; 可拆分时：f(n) = f(n-1)   可组合时：f(n) = f(n-2)    既可拆分又可组合时：f(n) = f(n-1) + f(n-2)
45.按序打印      线程锁：使用线程等待的方式实现执行屏障，使用释放线程等待的方式实现屏障消除
46.最长上升子序列    动态规划 在每个可能的最长上升子序列中附加当前元素nums[i]
47.超过经理收入的员工   sql left join
48.排序链表     归并排序   1.快慢指针找中点  2.递归mergesort   3.链表合并merge
49.寻找旋转排序数组中的最小值    1.递增序列直接返回  2.旋转点直接返回  3.非递增序列中继续二分法
50.旋转链表       1.先将链表闭合成环   2.找到相应的位置断开这个环，确定新的链表头和链表尾
51.反转链表II     头插法，每次将cur的next节点插入到pre后面
52.验证回文串     1.从字符串中挑选出字母和数字  2.双指针判断字符是否为回文
53.删除链表中的节点   1.修改当前值为next的值 2.删除next节点
54.换座位            1.偶数i-1 2.奇数i+1 3.最后一位i不变  select if(id%2=0,id-1,if(id=cnt,id,id+1)) as id,student from (select count(*) as cnt from seat)as a,seat order by id;
55.回文数            1.负数和个位为0的数都不是回文  2.将x的半数翻转后while，判断是否与x相等或者10倍关系
56.灯泡开关           1.第i个灯泡的反转次数等于它所有因子（包括1和i）的个数 2.只有平方数的因子个数不是成对出现 3.问题转换为n以内的平方数数量
57.反转字符串中的单词II   split + new stringBuilder(str).reverse().toString()
58.具有所有最深结点的最小子树   1.求左右子节点的最大深度  2.递归左右子节点，当左右子节点深度相等时，返回root
59.朋友圈            1.dfs每一个人的朋友圈关系 2.dfs每一个人其相邻的朋友圈关系


60.鸡蛋掉落        dp[j][i]  j个鸡蛋i次移动次数下的楼层数，如果楼层数大于等于N，返回i，否则返回N
61.重排链表
62.找到字符串中所有字母的异位词
63.二叉树的右视图
64.验证IP地址
65.Pow(x,n)
66.最长等差数列
67.二叉树的层平均值
68.打乱数组
69.组合总和II
70.岛屿数量
71.接雨水
72.x的平方根
73.k个一组翻转链表
74.复制带随机指针的链表
75.相交链表
76.二叉树的中序遍历
77.删除排序数组中的重复项
78.寻找重复数
79.亲密字符串

80.递增子序列
81.2的幂
82.解数独
83.合并二叉树
84.在每个树行中找最大值
85.另一个树的子树
86.部门工资最高的员工
87.四数之和
88.搜索二维矩阵II
89.多数元素
90.两数相加II
91.二分查找
92.翻转字符串里的单词
93.z子形变换
94.两数相除
95.组合总和
96.旋转图像
97.有序链表转换二叉搜索树
98.路径总和
99.二叉树的后序遍历

100.统计词频
101.第十行
102.只出现一次的数字II
103.字符串解码
104.二叉树的直径
105.错误的集合
106.最长同值路径
107.反转字符串
108.两数之和II-输入有序数组
109.计数质数
110.买卖股票的最佳时机II
111.分隔链表
112.二叉树的前序遍历
1.两数之和  双指针
2.最大子序列和  preMax = Math.max(preMax, preMax+num);   res = Math.max(res, preMax);
3.合并两个有序链表  while遍历链表，对比l1和l2，将小的连接到node上，最后返回head.next
4.无重复字符的最长子串  Map<Character,Integer>  字符及其出现的位置  保存最大不重复字符出现的位置  保存最长子串 保存字符出现的位置
5.寻找两个有序数组的中位数   保存到有序数组中 然后求中位数
6.螺旋矩阵    matrix[r1][c] [c1 - c2]  matrix[r][c2] [r1+1 - r2]  matrix[r2][c] [c2-1 - c1)  matrix[r][c1] [r2 - r1)
7.合并两个有序数组  排序+贪心算法
8.反转链表  ListNode next = cur.next  cur.next = next.next;  next.next = pre.next; pre.next = next;
9.两数相加    carry = sum / 10;
10.整数反转  ans = ans * 10 + pop
11.子集       res.add(new ArrayList<>(list));  dfs(res,list,nums,i+1);
12.搜索旋转排序数组  二分法 + 鉴别递增区间
13.字符串转换整数  1.跳过空字符 2.判断数字的符号 3.找出数字部分 4.溢出判断
14.爬楼梯  dp dp[i] = dp[i-1] + dp[i-2];
15.二叉树中的最大路径和   递归 ret = Math.max(ret, r.val + left + right);   Math.max(left, right) + r.val;
16.全排列    回溯算法 list.add(nums[i]);
17.最小路径和     逆序两层for循环 当前节点的值只与当前节点和min(左下节点和右下节点)有关  grid[i][j] = grid[i][j] + Math.min(grid[i + 1][j], grid[i][j + 1]);
18.最长回文子串  dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 2 || dp[i + 1][j - 1]);
19.火星词典  拓扑排序
20.三数之和  双指针

21.不同路径   dp dp[i][j] = dp[i-1][j] + dp[i][j - 1]
21.合并区间      Arrays.sort Comparator compare while start end  list.toArray(new int[list.size()][2])
22.有效的括号    stack push pop
23.环形链表      slow = head fast = head.next 快慢指针
24.全排列        backtrace(nums, start + 1, end, res)
25.不同路径||    动态规划：obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
26.打印零与奇偶数    Semaphore
27.螺旋矩阵||    迭代条件 装载数据 更新边界
28.盛最多水的容器   双指针法，移动较小高度的指针
29.有效的数独    boolean[][] row col block 记录某行列网格中是否出现过该数
30.三角形最小路径和  dp[j] 长度为j的最小路径和 = 下一层相邻的最小路径 + 当前路径
31.数组中的第K个最大元素  维护一个小根堆，小根堆保存k个最大的元素
32.验证二叉搜索树    中序遍历保证从小到大
33.二叉树的最大深度  递归：左右子树的最大深度+1
34.买卖股票的最佳时机  迭代每个价格，当前值减去历史最小值 最大值即为最大利润
35.最大正方形    动态规划 Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;  Math.min(Math.min(dp[j - 1], prev),dp[j]) + 1;
36.LRU缓存机制   LinkedHashMap 调用super方法  || hash表+双向链表    如果容量满了要删除最后一个数据队尾；数据访问通过hash表查找，每次访问还要把数据插入到队头
37.二叉树的层次遍历    队列保留每一层的TreeNode
38.最大矩形         dp[j] = matrix[i][j] == '1' ? dp[j] + 1 : 0; + 柱状图中的最大面积
39.用栈实现队列     将两个栈组合起来 数据进出push和pop

40.划分字母区间     数组：保留每个字符最后出现的位置  && 当字符的最大位置和索引值一致时，保存长度
41.二叉树的最近公共祖先    递归，如果发现左右子树都在该节点下，返回该节点；或者返回左右不为空的节点
42.最长重复子数组    动态规划dp[i][j] 前缀为A[i:]B[j:]最长重复子数组   二层遍历  状态转移 if(A[i-1] == B[j-1]) dp[i][j] = dp[i-1][j-1] + 1 max(dp[i][j])
43.合并K个排序链表    优先队列  链表dummy
44.解码方法      int[] dp = new int[2]; 可拆分时：f(n) = f(n-1)   可组合时：f(n) = f(n-2)    既可拆分又可组合时：f(n) = f(n-1) + f(n-2)
45.按序打印      线程锁：使用线程等待的方式实现执行屏障，使用释放线程等待的方式实现屏障消除
46.最长上升子序列    动态规划 在每个可能的最长上升子序列中附加当前元素nums[i]
47.超过经理收入的员工   sql left join
48.排序链表     归并排序   1.快慢指针找中点  2.递归mergesort   3.链表合并merge
49.寻找旋转排序数组中的最小值    1.递增序列直接返回  2.旋转点直接返回  3.非递增序列中继续二分法
50.旋转链表       1.先将链表闭合成环   2.找到相应的位置断开这个环，确定新的链表头和链表尾
51.反转链表II     头插法，每次将cur的next节点插入到pre后面
52.验证回文串     1.从字符串中挑选出字母和数字  2.双指针判断字符是否为回文
53.删除链表中的节点   1.修改当前值为next的值 2.删除next节点
54.换座位            1.偶数i-1 2.奇数i+1 3.最后一位i不变  select if(id%2=0,id-1,if(id=cnt,id,id+1)) as id,student from (select count(*) as cnt from seat)as a,seat order by id;
55.回文数            1.负数和个位为0的数都不是回文  2.将x的半数翻转后while，判断是否与x相等或者10倍关系
56.灯泡开关           1.第i个灯泡的反转次数等于它所有因子（包括1和i）的个数 2.只有平方数的因子个数不是成对出现 3.问题转换为n以内的平方数数量
57.反转字符串中的单词II   split + new stringBuilder(str).reverse().toString()
58.具有所有最深结点的最小子树   1.求左右子节点的最大深度  2.递归左右子节点，当左右子节点深度相等时，返回root
59.朋友圈            1.dfs每一个人的朋友圈关系 2.dfs每一个人其相邻的朋友圈关系


60.鸡蛋掉落        dp[j][i]  j个鸡蛋i次移动次数下的楼层数，如果楼层数大于等于N，返回i，否则返回N
61.重排链表        1.找到中位节点  2.翻转r链表  3.合并链表
62.找到字符串中所有字母的异位词   1.双指针，右指针加入source数组，左指针删除source数组  2.检查target与source的异动字符是否相等
63.二叉树的右视图   层次遍历:将每层的最后一个节点加入到结果中
64.验证IP地址       正则表达式  "(\\d||[1-9]\\d||1\\d\\d||2[0-4]\\d||25[0-5])"  "([\\da-fA-F]{1,4})"
65.Pow(x,n)         快速幂算法
66.最长等差数列      动态规划：dp[i][j] 以数字i结尾j为等差值的最长等差数列
67.二叉树的层平均值  层次遍历：计算每层的平均值
68.打乱数组          随机数交换数组的位置  rand.nextInt(max - min) + min
69.组合总和II        回溯 不重复
70.岛屿数量          dfs
71.接雨水            双指针 左右双指针向内逼近，从左右高度小的指针开始，保存最大左右高度，累计当前高度与左右高度的差值  单调栈 1.遍历数组时维护一个栈。如果当前的条形块小于或等于栈顶的条形块，我们将条形块的索引入栈 2.如果我们发现一个条形块长于栈顶，弹出栈顶元素并且累加答案到 ans
72.x的平方根         双指针 min max  x/m < m max = m else min = m
73.k个一组翻转链表    栈 + 计数  1.将前k个加入栈中 2.从栈中取出保存到临时链表中
74.复制带随机指针的链表   1.复制链表值和随机指针于当前节点的后面  2.拆分当前节点和后继克隆节点
75.相交链表               1.临时节点分别从A,B开始访问，当访问为null时，从对面的head开始进行访问
76.二叉树的中序遍历      基于栈的中序遍历
77.删除排序数组中的重复项   1.一个指针找前后不一致的地方  2.然后给nums重新赋值
78.寻找重复数          快慢指针 找环入口
79.亲密字符串          1.如果两个字符串长度不一致，直接false 2.如果两个字符串顺序一致，只有有2及2个以上的重复字符，返回false 3.当两个字符串顺序不一致时，当且仅当只有两处位置不一致，且不一致的字符相等，返回true，其余返回false

80.递增子序列          回溯算法：参照组合，1.不重复组合 2.2个及其以上递增序列
81.2的幂              &运算 2的幂必然最高位为1，其余位为0
82.解数独             1.用三个二维数组记录，该num是否被填充    2.dfs找寻空位置    3.在空位置处进行回溯算法，先进行判断是否已标记，填充，dfs，再回溯
83.合并二叉树          递归 对两棵树进行前序遍历 并对节点进行合并值相加
84.在每个树行中找最大值  层次遍历
85.另一个树的子树      1.递归判断B是不是A相同 || B是不是跟A的子树相同    2.递归判断A,B的值 && A,B左右子树的值
86.部门工资最高的员工    1.先按照部门id分组限制部门id和薪水   2.连接两个表，进行select
87.四数之和              指针kijh 两重循环 首先循环k，接着循环i，然后设定j和h
88.搜索二维矩阵II       从左下角开始搜索，大于target时，向上移动，小于target时，向右移动
89.多数元素             两个变量保存多数元素的值和次数，当前元素等于多数元素时，次数++，否则次数--，当次数为0时，下一个元素为多数元素
90.两数相加II            1.先将两个链表保存到栈中   2.将链表和保存到栈中    3.从栈中取出链表
91.二分查找             二分查找
92.翻转字符串里的单词    split拆分空格字符 放到stack里 然后取出来StringBuilder拼接起来
93.z子形变换             1.将所有的字符保存至List中，设定保存的位置i   2.从所有list中拼接字符串，返回结果
94.两数相除              计算被除数中包含几个除数  使用递归减法判断 求商
95.组合总和
96.旋转图像
97.有序链表转换二叉搜索树
98.路径总和
99.二叉树的后序遍历

100.统计词频
101.第十行
102.只出现一次的数字II
103.字符串解码
104.二叉树的直径
105.错误的集合
106.最长同值路径
107.反转字符串
108.两数之和II-输入有序数组
109.计数质数
110.买卖股票的最佳时机II
111.分隔链表
112.二叉树的前序遍历
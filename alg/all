****
数组array
****
135. 分发糖果 - Hard
每个孩子至少分配到 1 个糖果,相邻的孩子中，评分高的孩子必须获得更多的糖果
贪心算法  1.预先初始两个数组，全部填充为1  2.左迭代，当前比之前高，当前的糖果等于之前的数量加1  3.右迭代  4.最终最小糖果数等于最大左右数组
575. 分糖果 - 简单
给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数
思路：最大糖果的种类数  = min(set(kind), n/2)  1.排序，相同元素排列相接  2.cnt计数，限制最大数n/2
1103. 分糖果 II - 简单
给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始,剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友
思路：迭代糖果数，更新数组存储位置和存储数，更新剩余糖果数，原地加上糖果的负数
448. 找到所有数组中消失的数字 - 简单1 ≤ a[i] ≤ n
给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。
思路：普通替换法，置对应数组值为负值，不为负数的位置缺失
442. 数组中重复的数据 中等  找到所有出现两次的元素  1 ≤ a[i] ≤ n
输入数组中用数字的正负来表示该位置所对应数字是否已经出现过，如果数字对应的数组位置为负数，表示该数字对应的数组位置数重复
41. 缺失的第一个正数 - hard  -n +1 ≤ a[i] ≤ n-1  给定一个未排序的整数数组，找出其中没有出现的最小的正整数
1.先判断是否有1 2.将所有的0和负数转换为1 3。数字对应的位置转换为负数 4。第一个不是负数的为缺失数 5。没有缺失数的返回长度
765. 情侣牵手 - hard
计算最少交换座位的次数,保证(2N-2, 2N-1)连续排列
思路：遍历数组，它的另一半为当前值异或1，如果下一位不满足要求，遍历寻找，计算交换次数
面试题03. 数组中重复的数字 找出数组中重复的数字。  0 ≤ a[i] ≤ n - 1
思路：使用数字交换的方法，将数字放到对应的位置，判断是否已经存在 O(n) O(1)
面试题04. 二维数组中的查找  每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序
思路：线性查找，从左下角向右上角查找
面试题05. 替换空格  把字符串 s 中的每个空格替换成"%20"。
思路：字符数组。创建字符数组，遍历字符串，当遇到字符为空的时候，分别插入字符%20,否则插入当前字符，size控制字符数组位置
18. 杨辉三角
思路：一循环控制层数二循环控制每层数字，每层数字与上层数字相关
670. 最大交换
给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。
思路：1。候选数，标记其出现的位置  2。最大数为在候选数中出现的在当前位后面的数
238. 除自身以外数组的乘积
请不要使用除法，且在 O(n) 时间复杂度内完成此题。常数空间复杂度，除了输出数组以外
思路：左迭代res=num*k 右迭代 res=num*k
48. 旋转图像
给定一个 n × n 的二维矩阵表示一个图像，将图像顺时针旋转90度
思路：1。转置 i=j 2。反转 i，j = i，n-j-1
189. 旋转数组
思路：1.0 - n-1 2.0 - k-1 3.k - n-1
面试题11. 旋转数组的最小数字
思路：1.二分法，mid节点与r节点比较，判断为递增的区间，最小数字在左边，为递减的区间，最小数字在右边，相同大小，右指针减小，返回左指针位置
31.下一个排列
思路：1.从右向左扫描，找到第一次下降的位置i 2.从右向左扫描，找到第一次大于i的位置j  3.交换i，j 4.反转i+1 - len-1
3. 无重复字符的最长子串
思路：数组  1.迭代字符，判断map是否包含，更新start位置，更新res位置，将字符及其位置保存到map中
14. 最长公共前缀
思路：字符串数组  1.将第一个字符串和第二个字符串求前缀  2.用前缀与接下来的所有字符串对比求前缀
409. 最长回文串
思路：取偶数个+一个奇数  1.字符映射到字母数组表中   2.每个位置取偶数  3.长度小于原数组，长度加1

技巧：
1.数组计数出现的字符出现的位置和次数
2.左右迭代
3.数字对应数组下标标记为负数



****
栈
****
739. 每日温度
与比当前元素大的下一个元素的天数差
思路：单调栈，找比当前元素大的元素位置，计算相隔的天数
150. 逆波兰表达式求值
思路：1.用数组存储操作符，Arrays.asList(arr).contains()判断是否为操作符  2.遇到数字压入栈, 遇到操作符,弹出栈顶两个元素操作
20. 有效的括号
思路：1.输入为空，有效  2.输入为奇数，无效  3.Map记录}{括号之间的映射关系,便于contains  4.遇到左括号入栈，遇到右括号判断栈顶是否为左括号contains  5.判断栈是否为空
32. 最长有效括号  ")()())"  4
思路：1.栈先保存-1，保存左括号的位置  2.左括号入栈  3.右括号出栈，栈为空保存当前节点，栈不为空求最大有效括号
155.最小栈
思路：辅助栈-数据栈正常进出栈，辅助栈用于判断当前数字与栈顶大小，记录当前最小数
225.用队列实现栈
思路：1.a offer b->a 交换ab 2.b.pop b.peek 直接输出
232.用栈实现队列
思路：1.pop栈不为空直接输出 2.pop栈为空，push输入后输出 in.empty()
496.下一个更大元素 I
思路：使用栈查找比当前数大的元素，用kv保存，根据nums1生成答案
503. 下一个更大元素 II
思路：循环迭代当前元素，控制当前元素i，找到下一更大元素，保存到数组中
556. 下一个更大元素 III  32位整数的下一更大元素
思路：1.从右向左迭代找到比当前元素小的点i  2.从右到左找到第一个比i大的点j 3.交换i和j 4.反转i+1 - len - 1
71. 简化路径
1. '..'出栈  2.. .. "" 入栈
面试题06. 从尾到头打印链表
思路：用栈保存链表的值，再输出到数组中
946. 验证栈序列
思路：1.根据pop，控制栈的进出  2.对比是否能遍历整个push数组

技巧：
1.求下一个最大元素，最小元素
2.加减乘除操作数
3.有效括号


****
链表
****
2. 两数相加
思路：设立一个表示进位的变量carried，建立一个新链表，把输入的两个链表从头往后同时处理，每两个相加，将结果加上carried后的值作为一个新节点到新链表后面
445. 两数相加 II   要求右对齐相加
思路：1.将链表保存到栈中  2.将两个栈的和保存到栈中  3.从栈中取值链接成链表
83. 删除排序链表中的重复元素
思路：1.while迭代链表直到尾部   2.后继节点与当前结点的值相等，删除后继节点  3.不相等时，当前指针指向后继指针
82. 删除排序链表中的重复元素 II
思路：1.while迭代链表直到尾部 pre预置链表头 cur当前节点  2.当前结点与后继结点不重复时，更新pre和cur  3.重复时，一直重复，一直更新cur，如果迭代到表尾，pre.next=null,否则更新pre.next cur
160. 相交链表 简单
思路:while循环a!=b，当ab循环到链表尾时，交换链表头
141. 环形链表  是否有环
思路：快慢指针相遇则存在环
142. 环形链表 II  返回环入口
思路：1.找快慢指针相遇点   2.一个从相遇点一个从起始点开始迭代，直到相遇，为环入口
142. 环形链表 III  环的长度
思路：1.找到快慢指针第一次相遇的点  2.快慢指针第二次相遇的点  3.第一次点到第二次点之间的长度即为环的长度
234. 回文链表 easy
思路：1.快慢指针找中点  2.反转右链表   3.while同时迭代对比两链表
23. 合并K个排序链表
思路：1.创建优先队列QueuePriority  2.将链表头加入优先队列  3.从优先队列中取出指针添加到新建链表上，移动指针，将指针的后续结点添加到队列中
21.合并两个有序链表
思路：1.创建一个head及其node    2.遍历，对比l1和l2，将小的连接到node上，最后返回head.next
328. 奇偶链表
思路：1.新建两个指针头，分别指向奇数表头和偶数表头    2.while循环迭代生成奇偶链表  3.奇链表末尾链接偶数链表开头
86. 分隔链表
思路：1.新建两个表头  2.指针迭代链表，将大于x的数字添加到a链表，小于x的数字添加到b链表  3.连接两个链表
19.删除链表的倒数第N个节点
思路：1.新建两个指针指向头节点   2.指针q先行k个结点  3.然后q，p指针同时迭代直到q为null  4.删除p的后继结点即可
143.重排链表
思路：1.使用快慢指针找到链表的中心结点  2.将原始链表按照中心链表分割为两个链表，并将右链表反转  3.原地合并两个链表，将右链表插入到左链表
206.反转链表I
思路：1.next = cur.next  2.cur.next = pre  3.pre = cur  4.cur = next
92. 反转链表 II   反转m到n之间的链表
思路：1.pre指针先遍历到m  2.for m-n 头插法，每次将cur结点插入到pre结点后面
25. K 个一组翻转链表  diff
思路：1.创建一个头节点，while true循环    2.cnt计数，tmp迭代head  3.while计数k个，并将结点保存至stack   4.如果cnt不足k个，head直接添加到p  5.while将栈中的元素添加到p后
61. 旋转链表
思路：1.while找到链表尾结点和链表长度    2.链表尾结点连接头结点    3.新指针移动n-k，断开后继结点，返回后继结点
24. 两两交换链表中的节点
思路：1.新建头节点pre，while处理node1 node2 next    2.交换node1 node2 和pre next
面试题18. 删除链表的节点
思路：1.删除的位置有三种，首位，中间位，末尾   2.使用双指针，首先第一个位置，然后while判断中间位置和末尾

技巧：添加、相加、删除、删除重复、判断环、环入口、环长，找中心、反转链表、合并链表


****
二叉树
****
637. 二叉树的层平均值
思路：层次遍历求遍历每层的结点，每层结点数值求和取平均
889. 根据前序和后序遍历构造二叉树
思路:dfs 1.判断start与end的关系  2.根据前序遍历创建根节点，判断start与end的关系    3.while查找后序遍历中左子树的位置   4.dfs查找左右子树，返回cur
105. 从前序与中序遍历序列构造二叉树
思路：1.根据前序遍历创建根节点  2.从中序遍历开始迭代搜索，查找根节点，确定左子树mid-1，(mid - inPre) - 1和右子树的长度
106. 从中序与后序遍历序列构造二叉树
思路：1.根据后序遍历创建根节点  2.从中序遍历开始迭代搜索，查找根节点，确定左子树mid-1，(mid - inPre) - 1和右子树的长度
543. 二叉树的直径
思路：由二叉树的最长点数来求得二叉树得直径，直径 = 点数 - 1.  1.dfs求二叉树的最长点数  2.dfs 左子树点数 右子树点数  全局最长点数  返回当前点数
124.二叉树的最大路径和
思路：1.非空判断  2.dfs左右子树  3.全局最大路径和  返回当前结点最大路径和
687. 最长同值路径
思路：dfs 1.dfs二叉树  2.判断当前结点为null；dfs左右子节点；新地址记录左右子节点与当前结点的同值数；全局最长同值路径；返回当前结点最长同值路径
109. 有序链表转换二叉搜索树
思路：递归生成二叉树  1.当前节点为空，直接返回  2.左右子树找中间节点，断开中间节点链接 3.中间节点转化为根节点  4.中间节点为首结点，直接返回根节点  5.递归生成左右子树
114. 二叉树展开为链表
思路：1.迭代右子树，如果左子树不为空，将右子树上的结点连接到左子树的最右结点的右子树上   2.将左子树丢给右子树  3.迭代右子树
95. 不同的二叉搜索树 II
思路：dfs 1.迭代每个数字左右可能的结点    2.dfs左右子节点   3.迭代组成当前结点，加入到res中
96. 不同的二叉搜索树
思路：动态规划，左右子树个数的笛卡尔积累加 dp[i] += dp[j-1]*dp[i-j]
112. 路径总和
思路：dfs  1.边界值 当前为null 返回false  2.sum减去当前结点的值，左右子树为空的话，判读sum是否为null  3.递归左右子树
94. 二叉树的中序遍历
思路：1.当前结点不为null，创建栈，while保存当前节点，如果左子树不为null，访问左子树，否则出栈，访问结点，访问右子树
144. 二叉树的前序遍历
思路：1.当前结点不为null，创建栈，栈保存当前结点 2.while出栈，访问出栈元素右左元素加入到栈中，先访问右子树再访问左子树
145. 二叉树的后序遍历 - difficult
思路：1.同先序遍历，先访问左子树，再访问右子树  2.每次插入list的0位置
面试题33. 二叉搜索树的后序遍历序列
思路：1.如果长度为2，true 2.找到右子树的第一个节点的位子 3.验证右子树节点都大于根节点 4.dfs递归判断左右子树
226.翻转二叉树
思路：层次遍历反转左右子树
572. 另一个树的子树
思路：1.如果两棵树都为null，则true  2.对比s&&s的左树&&s的右树与t树是否相似  3.相似算法  左右子树都为空 返回true；判断当前结点&&左子树结点&&右子树结点
101.对称二叉树
思路：dfs 1.递归对比当前结点  当前结点都为null false；只有一个为null true；递归对比当前结点&&左子树右子树结点&&右子树左子树结点
98. 验证二叉搜索树
思路：1.while 栈 || root  2.while当前结点不为null，入栈，访问左子树  3.当前节点小于之前节点的值，返回false  4.更新之前结点的值，访问右子树
230.在二叉搜索树中查找第K小的数
思路：使用中序遍历得递归方法来访问，记录cnt，满足要求返回value
102.二叉树的层次遍历
思路：使用队列辅助
107.二叉树的层次遍历 II
思路：每次插入res的队首位置
235. 二叉搜索树的最近公共祖先
思路：找到一个结点的值在qp的值之间
236. 二叉树的最近公共祖先
思路：1.非空判断 || pq判断 返回当前结点  2.左右子树深度优先遍历  3.pq判断 返回当前结点  4.返回不为空的结点
1123. 最深叶节点的最近公共祖先
思路:1.采用深度优先遍历，每次往深度更大的子树递归  2.左右子树深度相同，表示获取到了最深叶子节点的最近公共祖先
617. 合并二叉树
思路：dfs 前序遍历合并二叉树  中左右
199. 二叉树的右视图
思路：层次遍历:将每层的最后一个节点加入到结果中
515. 在每个树行中找最大值
思路：层序遍历找最大值
108. 将有序数组转换为二叉搜索树
思路：前序遍历组成二叉搜索树，将中间位子的数字转换为根节点
865. 具有所有最深结点的最小子树
思路: 同1123. 最深叶节点的最近公共祖先
103. 二叉树的锯齿形层次遍历
思路：层次遍历，使用flag和add(0,x)控制保存位置

技巧：dfs 前序遍历 中序遍历  后序遍历  层次遍历  使用栈 队列辅助

****
动态规划
****
面试题10- I. 斐波那契数列
思路；使用动态规划，使用2个元素存储即可，当前元素的值只跟前两个元素有关系
01背包问题  每类物品只有一个
思路： dp[j]表示容量为j的背包所能装入物品的最大价值  1.二层循环，第二层背包容量逆序C-w[j-1]  2.dp[j] = Math.max(dp[j-w[i-1]]+v[i-1],dp[j])
02多重背包  每类物品都有个数限制，第i类物品最多可以装num[i]次
思路： dp[i][j] i种物品容量为j能装入得最大价值  1.二层循环，第二层背包容量从1-C  2.装不下dp[i][j] = dp[i-1][j]  3.装得下，求最大装入数量，迭代装入数量下得最大值价值
03完全背包  每类物品有无数个
思路： dp[j] 表示容量为j的背包所能装入物品的最大价值  2.二层循环，第二层循环顺序w[j-1]-C  2.dp[j] = Math.max(dp[j-weight[i-1]]+value[i-1],dp[j]);
55.跳跃游戏
思路：贪心算法  1.逆序迭代判断子位置是不是好位置，是的话更新子位置为lastPos，最后判断lastPos == 0
416. 分割等和子集
思路：01背包问题  在子集中找到一部分和为sum/2，则能够分割等和子集  1.判断是否为偶数  2.dp[j]集合中能否找到和为j的子集  3.二层循环，第二层循环逆序target-nums[i]
322. 零钱兑换
思路：03完全背包问题 dp[j]总金额为j所需最小的硬币数  1.二层循环，第二层循环coin[i]-amount  2.状态转移方程  dp[j] = Math.min(dp[j],dp[j-coins[i]]+1)
718. 最长重复子数组
思路：二层循环填表格  1.非空判断  2.dp[m][n] 两个数组中最长的重复子数组  状态转移  当前元素相等时 dp[i][j] = dp[i-1][j-1] + 1，保存全局最大值
10. 正则表达式匹配
思路: 1.当前字符匹配 || 当前字符为. dp[i][j] = dp[i-1][j-1] 2.当前字符为* 2.1 前一个字符不匹配 && 前一个字符不为. dp[i][j] = dp[i][j-1] 2.2否则 dp[i][j] = dp[i-1][j] || dp[i][j-1] || dp[i][j-2]
44.通配符匹配
思路：1.当前字符匹配 || 当前字符为？ dp[i][j] = dp[i-1][j-1] 2.dp[i][j] = dp[i][j-1] || dp[i-1][j]
300. 最长上升子序列
思路：dp[j] 长度为j的字符串中最长上升子序列大小  1.二层循环，如果能往长度为j的字符串末尾添加上升的子序列，则dp[i] = max(dp[j]+1,dp[i]),保存全局最大上升子序列大小
1027. 最长等差数列 | 最长等差子串
思路：dp[i][j] 子串i等差为step的最大长度   1.二层循环，求step，判断dp[j][step] > 0,更新dp[i][step] = max(dp[i][step],dp[j][step]+1),else dp[i][step]=2,保存最大dp
1143. 最长公共子序列
思路：填表格  1.当前元素相等时 dp[i][j] = dp[i-1][j-1] + 1  2.不相等时 dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])
最长公共子串
思路：填表格  1.当前元素相等时 dp[i][j] = dp[i-1][j-1] + 1  2.不相等时 dp[i][j] = 0
647. 回文子串
思路：二维数组作为备忘录  1.二层循环判断回文子串  2.当start=end，单个字符必定为回文子串  3.s[start]==s[end]&&(end-start<=1 || dp[start+1][end-1]) 考虑了奇偶长度的子串是否为回文
5.最长回文子串
思路：dp[i][j] 长度为i-j的字符串是不是回文 1.判断当前子串是不是回文  2.是回文的话，判断子串长度，更新子串
516.最长回文子序列
思路：dp[0][len-1] 长度为len的最长回文子序列   1.for 0..len-1  for i-1..0  2.判断s(i) == s(j) dp[j][i] = dp[j+1][i-1] + 2 else  dp[j][i] = Math.max(dp[j+1][i],dp[j][i-1])
221. 最大正方形
思路：1.二层动态规划，如果当前元素为1，dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1
72.最小的编辑距离
思路：填表格 1.dp[][] 初始化  2.当前两个元素相等时dp[i][j] = dp[i - 1][j - 1]  3.否则，dp[i][j] = (Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1])) + 1
120. 三角形最小路径和
思路：1.逆序从下至上来求最小路径和   2.当前结点的路径和为连接结点最小值加上当前结点  最后得到dp[0][0]
64.最小路径和
思路：填表格 1.逆序从右下到左上   2.当前最小路径和为当前节点+最小连接结点  grid[i][j] = grid[i][j] + Math.min(grid[i + 1][j], grid[i][j + 1]);  返回dp[0][0]
871. 最低加油次数
思路：0/1背包问题 dp[i] 加油i次下的最远距离  1.for  加油站个数： for  加油次数，逆序0/1背包问题：当能够加油时，求最远距离   2.for 求到达终点的加油次数
91. 解码方法
思路：填表格 1.从后向前迭代，0无解码方法,<26 两种解码方法，其他 一种解码方法  dp[i] = dp[i + 1] + dp[i + 2]  dp[i] = dp[i + 1]
115. 不同的子序列
思路：填表格 1.初始状态dp[0][i]=1   2.t.charAt(x) == s.charAt(y)，则f(x, y) = f(x, y - 1) + f(x - 1, y - 1)  else f(x, y) = f(x, y - 1)
96. 不同的二叉搜索树
思路：1.dp[0-1]=1  2.for 2-n:候选数量 for 1-i:作为根结点  dp[i] += dp[j-1]*dp[i-j]
132.分割回文串 II
思路：1.for end(1-n): for start(0-n): ispa(substrings) dp[i]=min(dp[i],dp[j]+1) 子串最小分割数+1
214.最短回文串
思路：1.反转s为r  2.指针迭代r，判断s.startswith   3.return r[:i] + s
887. 鸡蛋掉落
思路：1.min = min(min,max(dfs(k,n-i),dfs(k-1,i-1))+1)   2.逆序思维- dp[i][j]表示 i 个鸡蛋在 j 次尝试下可以测出的最多的层数   return j  for N  dp[0][i]=0 for k  dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;
62.不同路径
思路：1.dp[0][0]=1 2.dp[i][j] = dp[i-1][j] + dp[i][j - 1]
63. 不同路径 II 有障碍物
思路：1.初始化 dp[0][0] = 1,如果当前为0可以走，当前路径为上一个位置路径，否则为0  2.dp[i][j] = dp[i-1][j] + dp[i][j - 1]
980. 不同路径 III
思路：dfs   1.sum要走的个数  rc起始位置   2.dfs 当遇到2时sum==0 return 1:0  dfs上下左右  标记当前位置 还原当前位置
139.单词拆分I
思路：1.for end for start  if dp[start]&&contain(substrings(start,end)) dp[end]=true break  return dp[n]
140.单词拆分 II
思路：dp[k] 被用来存储用s[0:k−1] 可被拆分成合法单词的句子 1.if(dp[j].size() > 0 && wordDict.contains(s.substring(j, i)))   2.将dp中的list字符串与substrings拼接
343. 整数拆分
思路：完全背包问题 1.二层循环，i控制全局数，j控制拆分数字，状态转移memory[i] = Math.max(memory[i], Math.max(j * memory[i - j], j * (i - j)));

技巧：填表法，逆序填表法，0/1背包，完全背包，分割字符串\回文\单词

****
双指针
****
1.荷兰国旗问题
思路：双指针  1.首位指针标识插入位置  2.cur滑动指针识别当前数值，根据当前数值进行首位替换，移动首位指针和cur指针
两数之和
思路:1.迭代元素的同时，判断差值是否再hashmap里面，在的话，返回其位置  2.hashmap中不存在的话，将当前值和当前位置保存在hashmap里
2.对数组排序，然后用首位双指针的方法，缩小位置，求target
三数之和
思路：1.元素排序sort。迭代当前元素作为第一个元素，判断大小，判断重复，设定首位双指针，while判断，当三数之和满足要求时，添加到list中，继续while去重，同时缩小左右双指针，继续找满足要求的值
四数之和
思路：1.排序sort。第一层循环0-len-3作为第一个数，去重，判断最大四数字和与最小四数之和  2.第二层循环k+1-len-2，去重，定义指针，判断最大四数之和与最小四数之和  3.while双指针求四数之和，满足条件加入list，去重，缩小指针，继续判断四数之和
1163. 按字典序排在最后的子串
思路：求最大字母开头的子串  1.迭代数组，找最大字母的位置  2.当存在多个最大字母，继续判断其后续字母的大小，来更新起始位置k
209.长度最小的子数组
思路:1.迭代数组，求和，当和大于targt是，while求当前最小子数组长度i-l+1,增加左指针，减小和
862. 和至少为 K 的最短子数组
思路：1.迭代数组作为起始指针，while当j指针未到末尾时，相加子数组的和，如果大于k，求最小子数组长度
69. x 的平方根
思路：双指针二分法 1.首尾指针确定m  2.m*m与x的关系确定指针的位置
26. 删除排序数组中的重复项
思路：原地删除  1.cnt计数不重复个数，以及数字保存的位置  2.迭代元素，判断当前元素与上一个元素是否相等
接雨水
思路：1.初始化左右双指针，左右最大值  2.while，保存左右当前最大值，先计算最大值的那一边，res+=lm-h[l++]

技巧：左右双指针，二分法、滑动指针

****
dfs
****
127. 单词接龙
思路:BFS 1.判断list中是否包含endword  2.构建有向图，将只有一个不同的字符串之间通过链表数组关联起来  3.BFS计算从A-B的最短路径
279. 完全平方数
思路：dp 1.动态转移方程:如果当前的dp[i-j*j]的最小平方个数存在的话，dp[i]在此基础上直接+1
79. 单词搜索
1.二层for循环迭代每一个元素，从每一个元素开始dfs，如果dfs返回true，则返回true
2.dfs判断边界和是否相等，相等的话判断k的位置，达到最后返回true，否则保存当前board值，修改成*，dfs，还原board值，返回res
212. 单词搜索 II
思路：1.创建字典树  2.将当前字符插入到字典树  3.二层循环dfs  4.边界判断||已读判断||字典树子节点存在判断  5.更新字典树节点 6.数组访问更新  7.字典树是否访问到叶子节点保存结果  8.继续dfs访问  9.还原数组访问修改
面试题13. 机器人的运动范围
思路：1.一层dfs从0，0开始  2.边界判断  3.可达性判断k < (i%10 + i/10 + j%10 + j/10) 4.全局变量累加  5.标记访问，dfs
980. 不同路径 III
思路：1.二层循环判断要走的路径sum，找到开始节点i,j  2.dfs边界判断||已访问判断  3.如果到达终点判断是否走过所有路径  4.标记访问  5.dfs访问，还原访问
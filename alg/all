****
数组array
****
135. 分发糖果 - Hard
每个孩子至少分配到 1 个糖果,相邻的孩子中，评分高的孩子必须获得更多的糖果
贪心算法  1.预先初始两个数组，全部填充为1  2.左迭代，当前比之前高，当前的糖果等于之前的数量加1  3.右迭代  4.最终最小糖果数等于最大左右数组
575. 分糖果 - 简单
给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数
思路：最大糖果的种类数  = min(set(kind), n/2)  1.排序，相同元素排列相接  2.cnt计数，限制最大数n/2
1103. 分糖果 II - 简单
给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始,剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友
思路：迭代糖果数，更新数组存储位置和存储数，更新剩余糖果数，原地加上糖果的负数
448. 找到所有数组中消失的数字 - 简单
给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。
思路：普通替换法，置对应数组值为负值，不为负数的位置缺失
442. 数组中重复的数据 中等
找到所有出现两次的元素
输入数组中用数字的正负来表示该位置所对应数字是否已经出现过，如果数字对应的数组位置为负数，表示该数字对应的数组位置数重复
41. 缺失的第一个正数 - hard
给定一个未排序的整数数组，找出其中没有出现的最小的正整数
1.先判断是否有1 2.将所有的0和负数转换为1 3。数字对应的位置转换为负数 4。第一个不是负数的为缺失数 5。没有缺失数的返回长度
765. 情侣牵手 - hard
计算最少交换座位的次数,保证(2N-2, 2N-1)连续排列
思路：遍历数组，它的另一半为当前值异或1，如果下一位不满足要求，遍历寻找，计算交换次数
18. 杨辉三角
思路：一循环控制层数二循环控制每层数字，每层数字与上层数字相关
670. 最大交换
给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。
思路：1。候选数，标记其出现的位置  2。最大数为在候选数中出现的在当前位后面的数
238. 除自身以外数组的乘积
请不要使用除法，且在 O(n) 时间复杂度内完成此题。常数空间复杂度，除了输出数组以外
思路：左迭代res=num*k 右迭代 res=num*k
48. 旋转图像
给定一个 n × n 的二维矩阵表示一个图像，将图像顺时针旋转90度
思路：1。转置 i=j 2。反转 i，j = i，n-j-1
189. 旋转数组
思路：1.0 - n-1 2.0 - k-1 3.k - n-1
31.下一个排列
思路：1.从右向左扫描，找到第一次下降的位置i 2.从右向左扫描，找到第一次大于i的位置j  3.交换i，j 4.反转i+1 - len-1
技巧：
1.数组计数出现的字符出现的位置和次数
2.左右迭代
3.数字对应数组下标标记为负数



****
栈
****
739. 每日温度
与比当前元素大的下一个元素的天数差
思路：单调栈，找比当前元素大的元素位置，计算相隔的天数
150. 逆波兰表达式求值
思路：1.用数组存储操作符，Arrays.asList(arr).contains()判断是否为操作符  2.遇到数字压入栈, 遇到操作符,弹出栈顶两个元素操作
20. 有效的括号
思路：1.输入为空，有效  2.输入为奇数，无效  3.Map记录}{括号之间的映射关系,便于contains  4.遇到左括号入栈，遇到右括号判断栈顶是否为左括号contains  5.判断栈是否为空
32. 最长有效括号  ")()())"  4
思路：1.栈先保存-1，保存左括号的位置  2.左括号入栈  3.右括号出栈，栈为空保存当前节点，栈不为空求最大有效括号
155.最小栈
思路：辅助栈-数据栈正常进出栈，辅助栈用于判断当前数字与栈顶大小，记录当前最小数
225.用队列实现栈
思路：1.push 首先输入a队列中，然后拼接上b队列，交换a，b队列
232.用栈实现队列
思路：1.pop栈不为空直接输出 2.pop栈为空，push输入后输出
496.下一个更大元素 I
思路：使用栈查找比当前数大的元素，用kv保存，根据nums1生成答案
503. 下一个更大元素 II
思路：循环迭代当前元素，控制当前元素i，找到下一更大元素，保存到数组中
556. 下一个更大元素 III  32位整数的下一更大元素
思路：1.从右向左迭代找到比当前元素小的点i  2.从右到左找到第一个比i大的点j 3.交换i和j 4.反转i+1 - len - 1
71. 简化路径
1. '..'出栈  2.. .. "" 入栈

技巧：
1.求下一个最大元素，最小元素
2.加减乘除操作数
3.有效括号


****
链表
****
2. 两数相加
思路：设立一个表示进位的变量carried，建立一个新链表，把输入的两个链表从头往后同时处理，每两个相加，将结果加上carried后的值作为一个新节点到新链表后面
445. 两数相加 II   要求右对齐相加
思路：1.将链表保存到栈中  2.将两个栈的和保存到栈中  3.从栈中取值链接成链表
83. 删除排序链表中的重复元素
思路：1.while迭代链表直到尾部   2.后继节点与当前结点的值相等，删除后继节点  3.不相等时，当前指针指向后继指针
82. 删除排序链表中的重复元素 II
思路：1.while迭代链表直到尾部 pre预置链表头 cur当前节点  2.当前结点与后继结点不重复时，更新pre和cur  3.重复时，一直重复，一直更新cur，如果迭代到表尾，pre.next=null,否则更新pre.next cur
160. 相交链表 简单
思路:while循环a!=b，当ab循环到链表尾时，交换链表头
141. 环形链表  是否有环
思路：快慢指针相遇则存在环
142. 环形链表 II  返回环入口
思路：1.找快慢指针相遇点   2.一个从相遇点一个从起始点开始迭代，直到相遇，为环入口
142. 环形链表 III  环的长度
思路：1.找到快慢指针第一次相遇的点  2.快慢指针第二次相遇的点  3.第一次点到第二次点之间的长度即为环的长度
234. 回文链表 easy
思路：1.快慢指针找中点  2.反转右链表   3.while同时迭代对比两链表
23. 合并K个排序链表
思路：1.创建优先队列QueuePriority  2.将链表头加入优先队列  3.从优先队列中取出指针添加到新建链表上，移动指针，将指针的后续结点添加到队列中
21.合并两个有序链表
思路：1.创建一个head及其node    2.遍历，对比l1和l2，将小的连接到node上，最后返回head.next
328. 奇偶链表
思路：1.新建两个指针头，分别指向奇数表头和偶数表头    2.while循环迭代生成奇偶链表  3.奇链表末尾链接偶数链表开头
86. 分隔链表
思路：1.新建两个表头  2.指针迭代链表，将大于x的数字添加到a链表，小于x的数字添加到b链表  3.连接两个链表
19.删除链表的倒数第N个节点
思路：1.新建两个指针指向头节点   2.指针q先行k个结点  3.然后q，p指针同时迭代直到q为null  4.删除p的后继结点即可
143.重排链表
思路：1.使用快慢指针找到链表的中心结点  2.将原始链表按照中心链表分割为两个链表，并将右链表反转  3.原地合并两个链表，将右链表插入到左链表
206.反转链表I
思路：1.next = cur.next  2.cur.next = pre  3.pre = cur  4.cur = next
92. 反转链表 II   反转m到n之间的链表
思路：1.pre指针先遍历到m  2.for m-n 头插法，每次将cur结点插入到pre结点后面
25. K 个一组翻转链表  diff
思路：1.创建一个头节点，while true循环    2.cnt计数，tmp迭代head  3.while计数k个，并将结点保存至stack   4.如果cnt不足k个，head直接添加到p  5.while将栈中的元素添加到p后
61. 旋转链表
思路：1.while找到链表尾结点和链表长度    2.链表尾结点连接头结点    3.新指针移动n-k，断开后继结点，返回后继结点
24. 两两交换链表中的节点
思路：1.新建头节点pre，while处理node1 node2 next    2.交换node1 node2 和pre next

技巧：添加、相加、删除、删除重复、判断环、环入口、环长，找中心、反转链表、合并链表


****
二叉树
****
637. 二叉树的层平均值
思路：层次遍历求遍历每层的结点，每层结点数值求和取平均
889. 根据前序和后序遍历构造二叉树
思路:dfs 1.判断start与end的关系  2.根据前序遍历创建根节点，判断start与end的关系    3.while查找后序遍历中左子树的位置   4.dfs查找左右子树，返回cur
105. 从前序与中序遍历序列构造二叉树
思路：1.根据前序遍历创建根节点  2.从中序遍历开始迭代搜索，查找根节点，确定左子树mid-1，(mid - inPre) - 1和右子树的长度
106. 从中序与后序遍历序列构造二叉树
思路：1.根据后序遍历创建根节点  2.从中序遍历开始迭代搜索，查找根节点，确定左子树mid-1，(mid - inPre) - 1和右子树的长度
543. 二叉树的直径
思路：由二叉树的最长点数来求得二叉树得直径，直径 = 点数 - 1.  1.dfs求二叉树的最长点数  2.dfs 左子树点数 右子树点数  全局最长点数  返回当前点数
124.二叉树的最大路径和
思路：1.非空判断  2.dfs左右子树  3.全局最大路径和  返回当前结点最大路径和
687. 最长同值路径
思路：dfs 1.dfs二叉树  2.判断当前结点为null；dfs左右子节点；新地址记录左右子节点与当前结点的同值数；全局最长同值路径；返回当前结点最长同值路径
109. 有序链表转换二叉搜索树
思路：递归生成二叉树  1.当前节点为空，直接返回  2.左右子树找中间节点，断开中间节点链接 3.中间节点转化为根节点  4.中间节点为首结点，直接返回根节点  5.递归生成左右子树
114. 二叉树展开为链表
思路：1.迭代右子树，如果左子树不为空，将右子树上的结点连接到左子树的最右结点的右子树上   2.将左子树丢给右子树  3.迭代右子树
95. 不同的二叉搜索树 II
思路：dfs 1.迭代每个数字左右可能的结点    2.dfs左右子节点   3.迭代组成当前结点，加入到res中
96. 不同的二叉搜索树
思路：动态规划，左右子树个数的笛卡尔积累加 dp[i] += dp[j-1]*dp[i-j]
112. 路径总和
思路：dfs  1.边界值 当前为null 返回false  2.sum减去当前结点的值，左右子树为空的话，判读sum是否为null  3.递归左右子树
94. 二叉树的中序遍历
思路：1.当前结点不为null，创建栈，while保存当前节点，如果左子树不为null，访问左子树，否则出栈，访问结点，访问右子树
144. 二叉树的前序遍历
思路：1.当前结点不为null，创建栈，栈保存当前结点 2.while出栈，访问出栈元素右左元素加入到栈中，先访问右子树再访问左子树
145. 二叉树的后序遍历 - difficult
思路：1.同先序遍历，先访问左子树，再访问右子树  2.每次插入list的0位置
226.翻转二叉树
思路：层次遍历反转左右子树
572. 另一个树的子树
思路：1.如果两棵树都为null，则true  2.对比s&&s的左树&&s的右树与t树是否相似  3.相似算法  左右子树都为空 返回true；判断当前结点&&左子树结点&&右子树结点
101.对称二叉树
思路：dfs 1.递归对比当前结点  当前结点都为null false；只有一个为null true；递归对比当前结点&&左子树右子树结点&&右子树左子树结点
98. 验证二叉搜索树
思路：1.while 栈 || root  2.while当前结点不为null，入栈，访问左子树  3.当前节点小于之前节点的值，返回false  4.更新之前结点的值，访问右子树
230.在二叉搜索树中查找第K小的数
思路：使用中序遍历得递归方法来访问，记录cnt，满足要求返回value
102.二叉树的层次遍历
思路：使用队列辅助
107.二叉树的层次遍历 II
思路：每次插入res的队首位置
235. 二叉搜索树的最近公共祖先
思路：找到一个结点的值在qp的值之间
236. 二叉树的最近公共祖先
思路：1.非空判断 || pq判断 返回当前结点  2.左右子树深度优先遍历  3.pq判断 返回当前结点  4.返回不为空的结点
1123. 最深叶节点的最近公共祖先
思路:1.采用深度优先遍历，每次往深度更大的子树递归  2.左右子树深度相同，表示获取到了最深叶子节点的最近公共祖先
617. 合并二叉树
思路：dfs 前序遍历合并二叉树  中左右
199. 二叉树的右视图
思路：层次遍历:将每层的最后一个节点加入到结果中
515. 在每个树行中找最大值
思路：层序遍历找最大值
108. 将有序数组转换为二叉搜索树
思路：前序遍历组成二叉搜索树，将中间位子的数字转换为根节点
865. 具有所有最深结点的最小子树
思路: 同1123. 最深叶节点的最近公共祖先
103. 二叉树的锯齿形层次遍历
思路：层次遍历，使用flag和add(0,x)控制保存位置
